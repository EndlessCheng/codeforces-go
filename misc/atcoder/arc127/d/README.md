既然是取 min，那么从高位往低位看，找到第一个异或不同的比特位。
例如在某个比特位上 a[i] b[i] a[j] b[j] 分别为 0 0 0 1（或者 0 1 0 0），那么后面就不用比了，a[i] ⊕ a[j] 更小，把 a[i] ⊕ a[j] 的贡献加到答案中。
怎么算贡献？对于这个比特位，把满足「a[i]=0 且 b[i]=0」的 a[i] 分到一组（记作 P），把满足「a[i]=0 且 b[i]=1」的 a[i] 分到另一组（记作 Q）。
枚举 k=0~17，那么 ∑((P 中第 k 个比特位是 1 的元素个数) * (Q 中第 k 个比特位是 0 的元素个数) + (P 中第 k 个比特位是 0 的元素个数) * (Q 中第 k 个比特位是 1 的元素个数)) * 2^k 就是贡献。另见 https://www.luogu.com.cn/blog/endlesscheng/post-ling-cha-ba-ti-ti-mu-lie-biao

一般地，根据【a[i] 当前比特位 = 0/1】和【b[i] 当前比特位 = 0/1】，分成四组：

- (0,0)：表示【a[i] 当前比特位 = 0】和【b[i] 当前比特位 = 0】
- (0,1)：表示【a[i] 当前比特位 = 0】和【b[i] 当前比特位 = 1】
- (1,0)：表示【a[i] 当前比特位 = 1】和【b[i] 当前比特位 = 0】
- (1,1)：表示【a[i] 当前比特位 = 1】和【b[i] 当前比特位 = 1】

这四组两两之间再组合，有 C(4,2)=6 种情况：

- (0,0) 和 (0,1)：表示 a[i] b[i] a[j] b[j] 分别为 0 0 0 1（或者 0 1 0 0），把 a[i] ⊕ a[j] 的贡献加到答案中。
- (1,0) 和 (1,1)：同上，把 a[i] ⊕ a[j] 的贡献加到答案中。
- (0,0) 和 (1,0)：表示 a[i] b[i] a[j] b[j] 分别为 0 0 1 0（或者 1 0 0 0），把 b[i] ⊕ b[j] 的贡献加到答案中。
- (0,1) 和 (1,1)：同上，把 b[i] ⊕ b[j] 的贡献加到答案中。
- (0,0) 和 (1,1)：这两组合并在一起，继续枚举更低的比特位。这可以递归解决。
- (0,1) 和 (1,0)：这两组合并在一起，继续枚举更低的比特位。这可以递归解决。

递归边界：当前比特位等于 -1，表示当前这个组中所有 a[i] 均等于 b[i]，那么直接计算 a[i] ⊕ a[j] 的贡献。

https://atcoder.jp/contests/arc127/submissions/46727373
