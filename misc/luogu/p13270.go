package main

import (
	. "fmt"
	"io"
)

// https://space.bilibili.com/206214
func p13270(in io.Reader, out io.Writer) {
	var n int
	var s string
	Fscan(in, &n, &s)
	s += s
	// 如果要返回一个和原串不同的字符串，初始化 i=1, j=2
	i := 0
	for j := 1; j < n; {
		// 暴力比较：是 i 开头的字典序小，还是 j 开头的字典序小？
		// 相同就继续往后比，至多循环 n 次（如果循环 n 次，说明所有字母都相同，不用再比了）
		k := 0
		for k < n && s[i+k] == s[j+k] {
			k++
		}
		if k >= n {
			break
		}

		if s[i+k] < s[j+k] { // 改成 > 则返回字典序最大的
			// 从 i 开始比从 j 开始更小，排除 j
			// 此外：
			// 从 i+1 开始比从 j+1 开始更小，所以从 j+1 开始不可能是答案，排除
			// 从 i+2 开始比从 j+2 开始更小，所以从 j+2 开始不可能是答案，排除
			// ……
			// 从 i+k 开始比从 j+k 开始更小，所以从 j+k 开始不可能是答案，排除
			// 所以下一个「可能是答案」的开始位置是 j+k+1
			j += k + 1
		} else {
			// 从 j 开始比从 i 开始更小，更新 i=j
			// 此外：
			// 从 j+1 开始比从 i+1 开始更小，所以从 i+1 开始不可能是答案，排除
			// 从 j+2 开始比从 i+2 开始更小，所以从 i+2 开始不可能是答案，排除
			// ……
			// 从 j+k 开始比从 i+k 开始更小，所以从 i+k 开始不可能是答案，排除
			// 所以把 j 跳到 i+k+1，不过这可能比 j+1 小，所以与 j+1 取 max
			// 综上所述，下一个「可能是答案」的开始位置是 max(j+1,i+k+1)
			i, j = j, max(j, i+k)+1
		}
		// 每次要么排除 k+1 个与 i 相关的位置（这样的位置至多 n 个），要么排除 k+1 个与 j 相关的位置（这样的位置至多 n 个）
		// 所以上面关于 k 的循环，∑k <= 2n，所以二重循环的总循环次数是 O(n) 的
	}
	Fprintf(out, "%s", s[i:i+n])
}

//func main() { p13270(bufio.NewReader(os.Stdin), os.Stdout) }
