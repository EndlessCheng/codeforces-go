一、优化前

本题属于划分型 DP，定义 dfs(k,i,j) 表示从 s 的前 i 个字母中取出 k 个子串，拼接得到 t 的前 j 个字母的方案数。

不选 s[i]：
dfs(k,i-1,j)

选 s[i]（注意前提是从 s 取出的这个子串和 t 中对应子串是一样的，即 s[i]=t[j], s[i-1]=t[j-1], ...）
子串长度=1：dfs(k-1,i-1,j-1)
子串长度=2：dfs(k-1,i-2,j-2)
子串长度=3：dfs(k-1,i-3,j-3)
...

这样做时间是 O(knm^2)，无法接受。

二、优化

注意到当 s[i]=t[j] 时，我们可以继续比较 s[i-1] 和 t[j-1]，向左寻找更长的子串。
但在 dfs(*,i-1,j-1) 中，我们也会比较 s[i-1] 和 t[j-1]，也会继续向左寻找更长的子串。
这样就重复计算了。

不妨添加一个维度，用状态机 DP 思考。
定义 dfs(k,i,j,on) 表示从 s 的前 i 个字母中取出 k 个子串，得到 t 的前 j 个字母的方案数。
on=0 表示尚未开始匹配（此时开始匹配，那么当前字母是子串的末尾字母）。
on=1 表示已经开始匹配（当前字母不是子串的末尾字母）。

对于 on=0：
不选 s[i]：dfs(k,i-1,j,0)
如果 s[i]=t[j]，那么有两种情况：
选 s[i] 并且子串长度恰好为 1：dfs(k-1,i-1,j-1,0)
选 s[i] 并且子串长度超过 1：dfs(k,i-1,j-1,1) 注意这里没有减小 k，等到匹配完了再减小。
这两个选的情况，可以合并成 dfs(k,i,j,1)，所以有
dfs(k,i,j,0) = dfs(k,i-1,j,0) + dfs(k,i,j,1)

对于 on=1：
如果 s[i]!=t[j]：直接返回 0。
否则：
在这里结束：dfs(k-1,i-1,j-1,0)
继续向左匹配：dfs(k,i-1,j-1,1)
所以在 s[i]=t[j] 时，有
dfs(k,i,j,1) = dfs(k-1,i-1,j-1,0) + dfs(k,i-1,j-1,1)

时间空间都是 O(knm)。

记忆化搜索可以直接拿到 90 分。少的那 10 分是因为这题卡内存，或者说空间复杂度需要是 O(nm)。
要想拿到 100 分，需要翻译成递推，然后把第一个维度优化一下（用两个数组滚动）。

注：也可以用前缀和优化，但我感觉状态机 DP 更好想。

