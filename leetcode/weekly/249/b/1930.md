## 技巧：枚举中间

对于有三个变量的问题，枚举中间的变量往往更好算。

为什么？比如问题有三个下标，需要满足 $0\le i<j<k<n$，对比一下：

- 枚举 $i$，后续计算中还需保证 $j < k$。
- 枚举 $j$，那么 $i$ 和 $k$ 自动被 $j$ 隔开，互相独立，后续计算中无需关心 $i$ 和 $k$ 的位置关系。

所以枚举中间更简单。

## 前后缀分解

枚举 $s[i]$ 是子序列的中间字母，那么对于左右两边的字母 $\alpha = \texttt{a},\texttt{b},\ldots,\texttt{z}$，我们需要判断：

- $s$ 的前缀 $[0,i-1]$ 中有没有 $\alpha$？
- $s$ 的后缀 $[i+1,n-1]$ 中有没有 $\alpha$？

暴力找是 $\mathcal{O}(n)$ 的，如何加速？

定义 $\textit{pre}[i]$ 表示 $s$ 的前缀 $[0,i-1]$ 的字母集合。往 $\textit{pre}[i-1]$ 中添加 $s[i]$，就得到了 $\textit{pre}[i]$。

定义 $\textit{suf}[i]$ 表示 $s$ 的后缀 $[i+1,n-1]$ 的字母集合。往 $\textit{suf}[i+1]$ 中添加 $s[i]$，就得到了 $\textit{suf}[i]$。

有了 $\textit{pre}$ 和 $\textit{suf}$，如果 $\textit{pre}[i-1]$ 和 $\textit{suf}[i+1]$ 中都包含 $\alpha$，那么就找到了一个长为 $3$ 的回文子序列 $\alpha + s[i] + \alpha$。

题目要求相同的子序列只计数一次。这可以用哈希集合去重，也可以用 $26\times 26$ 的布尔数组记录找到的子序列的后两个字母（第一个字母一定等于第三个字母，无需记录）。

## 优化前

```py [sol-Python3]
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        n = len(s)
        # 统计每个后缀有哪些字母
        suf = [set() for _ in range(n + 1)]
        for i in range(n - 1, 1, -1):
            suf[i] = suf[i + 1].copy()
            suf[i].add(s[i])

        pre = set()
        st = set()
        # 枚举回文子序列的中间字母 s[i]
        for i in range(1, n - 1):
            pre.add(s[i - 1])  # 统计前缀有哪些字母
            for ch in pre & suf[i + 1]:  # s[i] 的左右两侧都有字母 ch
                st.add(s[i] + ch)  # 记录回文子序列的后两个字母

        return len(st)
```

```java [sol-Java]
class Solution {
    public int countPalindromicSubsequence(String S) {
        char[] s = S.toCharArray();
        int n = s.length;
        // 统计每个后缀有哪些字母
        boolean[][] suf = new boolean[n + 1][26];
        for (int i = n - 1; i >= 2; i--) {
            suf[i] = suf[i + 1].clone();
            suf[i][s[i] - 'a'] = true;
        }

        boolean[] pre = new boolean[26];
        boolean[][] has = new boolean[26][26];
        // 枚举回文子序列的中间字母 s[i]
        for (int i = 1; i < n - 1; i++) {
            pre[s[i - 1] - 'a'] = true; // 统计前缀有哪些字母
            for (int j = 0; j < 26; j++) {
                if (pre[j] && suf[i + 1][j]) { // s[i] 的左右两侧都有字母 j
                    has[s[i] - 'a'][j] = true; // 记录回文子序列的后两个字母
                }
            }
        }

        int ans = 0;
        for (boolean[] row : has) {
            for (boolean ok : row) {
                if (ok) {
                    ans++;
                }
            }
        }
        return ans;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    int countPalindromicSubsequence(string s) {
        int n = s.size();
        // 统计每个后缀有哪些字母
        vector<array<int8_t, 26>> suf(n + 1);
        for (int i = n - 1; i >= 2; i--) {
            suf[i] = suf[i + 1];
            suf[i][s[i] - 'a'] = true;
        }

        int pre[26]{};
        bool has[26][26]{};
        // 枚举回文子序列的中间字母 s[i]
        for (int i = 1; i < n - 1; i++) {
            pre[s[i - 1] - 'a'] = true; // 统计前缀有哪些字母
            for (int j = 0; j < 26; j++) {
                if (pre[j] && suf[i + 1][j]) { // s[i] 的左右两侧都有字母 j
                    has[s[i] - 'a'][j] = true; // 记录回文子序列的后两个字母
                }
            }
        }

        int ans = 0;
        for (auto& row : has) {
            ans += reduce(row, row + 26, 0);
        }
        return ans;
    }
};
```

```go [sol-Go]
func countPalindromicSubsequence(s string) (ans int) {
	n := len(s)
	// 统计每个后缀有哪些字母
	suf := make([][26]bool, n+1)
	for i := n - 1; i >= 2; i-- {
		suf[i] = suf[i+1]
		suf[i][s[i]-'a'] = true
	}

	pre := [26]bool{}
	has := [26][26]bool{}
	// 枚举回文子序列的中间字母 s[i]
	for i := 1; i < n-1; i++ {
		pre[s[i-1]-'a'] = true // 统计前缀有哪些字母
		for j := range 26 {
			if pre[j] && suf[i+1][j] { // s[i] 的左右两侧都有字母 j
				has[s[i]-'a'][j] = true // 记录回文子序列的后两个字母
			}
		}
	}

	for _, row := range has {
		for _, ok := range row {
			if ok {
				ans++
			}
		}
	}
	return
}
```

```js [sol-JavaScript]
var countPalindromicSubsequence = function(s) {
    const n = s.length;
    const ordA = 'a'.charCodeAt(0);
    // 统计每个后缀有哪些字母
    const suf = Array.from({ length: n + 1 }, () => Array(26).fill(false));
    for (let i = n - 1; i >= 0; i--) {
        suf[i] = suf[i + 1].slice();
        suf[i][s.charCodeAt(i) - ordA] = true;
    }

    const pre = Array(26).fill(false);
    const has = Array.from({ length: 26 }, () => Array(26).fill(false));
    // 枚举回文子序列的中间字母 s[i]
    for (let i = 1; i < n - 1; i++) {
        pre[s.charCodeAt(i - 1) - ordA] = true; // 统计前缀有哪些字母
        for (let j = 0; j < 26; j++) {
            if (pre[j] && suf[i + 1][j]) { // s[i] 的左右两侧都有字母 j
                has[s.charCodeAt(i) - ordA][j] = true; // 记录回文子序列的后两个字母
            }
        }
    }

    let ans = 0;
    for (const row of has) {
        ans += _.sum(row);
    }
    return ans;
};
```

```rust [sol-Rust]
impl Solution {
    pub fn count_palindromic_subsequence(s: String) -> i32 {
        let s = s.as_bytes();
        let n = s.len();

        // 统计每个后缀有哪些字母
        let mut suf = vec![[false; 26]; n + 1];
        for i in (2..n).rev() {
            suf[i] = suf[i + 1];
            suf[i][(s[i] - b'a') as usize] = true;
        }

        let mut pre = [false; 26];
        let mut has = [[false; 26]; 26];
        // 枚举回文子序列的中间字母 s[i]
        for i in 1..n - 1 {
            pre[(s[i - 1] - b'a') as usize] = true; // 统计前缀有哪些字母
            for j in 0..26 {
                if pre[j] && suf[i + 1][j] { // s[i] 的左右两侧都有字母 j
                    has[(s[i] - b'a') as usize][j] = true; // 记录回文子序列的后两个字母
                }
            }
        }

        has.into_iter()
            .map(|row| row.into_iter().filter(|&b| b).count() as i32)
            .sum()
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n|\Sigma|)$，其中 $n$ 是 $s$ 的长度，$|\Sigma|=26$ 是字符集合的大小。
- 空间复杂度：$\mathcal{O}(n|\Sigma|)$。

## 位运算优化

我们可以把集合（布尔数组）压缩成一个二进制数，原理请看 [从集合论到位运算，常见位运算技巧分类总结！](https://leetcode.cn/circle/discuss/CaOJ45/)

用位运算可以 $\mathcal{O}(1)$ 求出 $\textit{pre}$ 和 $\textit{suf}[i+1]$ 的交集。

```py [sol-Python3]
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        n = len(s)
        ord_a = ord('a')
        # 统计每个后缀有哪些字母
        suf = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suf[i] = suf[i + 1] | 1 << (ord(s[i]) - ord_a)

        pre = 0
        masks = defaultdict(int)
        # 枚举回文子序列的中间字母 s[i]
        for i in range(1, n - 1):
            pre |= 1 << (ord(s[i - 1]) - ord_a)  # 统计前缀有哪些字母
            # pre & suf[i+1] O(1) 计算在 s[i] 左右两侧都有的字母
            masks[s[i]] |= pre & suf[i + 1]

        return sum(mask.bit_count() for mask in masks.values())
```

```java [sol-Java]
class Solution {
    public int countPalindromicSubsequence(String S) {
        char[] s = S.toCharArray();
        int n = s.length;
        // 统计每个后缀有哪些字母
        int[] suf = new int[n + 1];
        for (int i = n - 1; i >= 0; i--) {
            suf[i] = suf[i + 1] | (1 << (s[i] - 'a'));
        }

        int pre = 0;
        int[] has = new int[26];
        // 枚举回文子序列的中间字母 s[i]
        for (int i = 1; i < n - 1; i++) {
            pre |= 1 << (s[i - 1] - 'a'); // 统计前缀有哪些字母
            // pre & suf[i+1] O(1) 计算在 s[i] 左右两侧都有的字母
            has[s[i] - 'a'] |= pre & suf[i + 1];
        }

        int ans = 0;
        // 比如 has[1] = 1101 表示 s 中有回文子序列 aba、cbc 和 dbd
        for (int mask : has) {
            ans += Integer.bitCount(mask);
        }
        return ans;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    int countPalindromicSubsequence(string s) {
        int n = s.size();
        // 统计每个后缀有哪些字母
        vector<int> suf(n + 1);
        for (int i = n - 1; i >= 0; i--) {
            suf[i] = suf[i + 1] | 1 << (s[i] - 'a');
        }

        int pre = 0;
        int has[26]{};
        // 枚举回文子序列的中间字母 s[i]
        for (int i = 1; i < n - 1; i++) {
            pre |= 1 << (s[i - 1] - 'a'); // 统计前缀有哪些字母
            // pre & suf[i+1] O(1) 计算在 s[i] 左右两侧都有的字母
            has[s[i] - 'a'] |= pre & suf[i + 1];
        }

        int ans = 0;
        // 比如 has[1] = 1101 表示 s 中有回文子序列 aba、cbc 和 dbd
        for (int mask : has) {
            ans += popcount((uint32_t) mask);
        }
        return ans;
    }
};
```

```go [sol-Go]
func countPalindromicSubsequence(s string) (ans int) {
	n := len(s)
	// 统计每个后缀有哪些字母
	suf := make([]int, n+1)
	for i := n - 1; i >= 0; i-- {
		suf[i] = suf[i+1] | 1<<(s[i]-'a')
	}

	pre := 0
	has := [26]int{}
	// 枚举回文子序列的中间字母 s[i]
	for i := 1; i < n-1; i++ {
		pre |= 1 << (s[i-1] - 'a') // 统计前缀有哪些字母
		// pre & suf[i+1] O(1) 计算在 s[i] 左右两侧都有的字母
		has[s[i]-'a'] |= pre & suf[i+1]
	}

	// 比如 has[1] = 1101 表示 s 中有回文子序列 aba、cbc 和 dbd
	for _, mask := range has {
		ans += bits.OnesCount(uint(mask))
	}
	return
}
```

```js [sol-JavaScript]
var countPalindromicSubsequence = function(s) {
    const n = s.length;
    const ordA = 'a'.charCodeAt(0);
    // 统计每个后缀有哪些字母
    const suf = Array(n + 1).fill(0);
    for (let i = n - 1; i >= 0; i--) {
        suf[i] = suf[i + 1] | 1 << (s.charCodeAt(i) - ordA);
    }

    const has = Array(26).fill(0);
    let pre = 0;
    // 枚举回文子序列的中间字母 s[i]
    for (let i = 1; i < n - 1; i++) {
        pre |= 1 << (s.charCodeAt(i - 1) - ordA); // 统计前缀有哪些字母
        // pre & suf[i+1] O(1) 计算在 s[i] 左右两侧都有的字母
        has[s.charCodeAt(i) - ordA] |= pre & suf[i + 1];
    }

    let ans = 0;
    // 比如 has[1] = 1101 表示 s 中有回文子序列 aba、cbc 和 dbd
    for (const mask of has) {
        ans += bitCount32(mask);
    }
    return ans;
};

// 参考 Java 的 Integer.bitCount
function bitCount32(i) {
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
}
```

```rust [sol-Rust]
impl Solution {
    pub fn count_palindromic_subsequence(s: String) -> i32 {
        let s = s.as_bytes();
        let n = s.len();

        // 统计每个后缀有哪些字母
        let mut suf = vec![0; n + 1];
        for i in (0..n).rev() {
            suf[i] = suf[i + 1] | 1 << (s[i] - b'a');
        }

        let mut pre = 0;
        let mut has = [0u32; 26];
        // 枚举回文子序列的中间字母 s[i]
        for i in 1..n - 1 {
            pre |= 1 << (s[i - 1] - b'a'); // 统计前缀有哪些字母
            // pre & suf[i+1] O(1) 计算在 s[i] 左右两侧都有的字母
            has[(s[i] - b'a') as usize] |= pre & suf[i + 1];
        }

        // 比如 has[1] = 1101 表示 s 中有回文子序列 aba、cbc 和 dbd
        has.into_iter().map(|mask| mask.count_ones() as i32).sum()
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n+|\Sigma|)$，其中 $n$ 是 $s$ 的长度，$|\Sigma|=26$ 是字符集合的大小。
- 空间复杂度：$\mathcal{O}(n+|\Sigma|)$。

## 空间优化

```py [sol-Python3]
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        n = len(s)
        ord_a = ord('a')
        suf_cnt = [0] * 26  # 统计后缀每个字母的个数
        suf = 0
        for ch in s[1:]:
            ch = ord(ch) - ord_a
            suf_cnt[ch] += 1
            suf |= 1 << ch

        pre = 0
        masks = [0] * 26
        for i in range(1, n - 1):
            pre |= 1 << (ord(s[i - 1]) - ord_a)
            ch = ord(s[i]) - ord_a
            suf_cnt[ch] -= 1
            if suf_cnt[ch] == 0:  # 现在，后缀 [i+1,n-1] 不包含字母 ch
                suf ^= 1 << ch  # 从 suf 中去掉 ch
            masks[ch] |= pre & suf

        return sum(mask.bit_count() for mask in masks)
```

```java [sol-Java]
class Solution {
    public int countPalindromicSubsequence(String s) {
        int n = s.length();
        int[] sufCnt = new int[26]; // 统计后缀每个字母的个数
        int suf = 0;
        for (int i = 1; i < n; i++) {
            int ch = s.charAt(i) - 'a';
            sufCnt[ch]++;
            suf |= 1 << ch;
        }

        int pre = 0;
        int[] has = new int[26];
        for (int i = 1; i < n - 1; i++) {
            pre |= 1 << (s.charAt(i - 1) - 'a');
            int ch = s.charAt(i) - 'a';
            sufCnt[ch]--;
            if (sufCnt[ch] == 0) { // 现在，后缀 [i+1,n-1] 不包含字母 ch
                suf ^= 1 << ch; // 从 suf 中去掉 ch
            }
            has[ch] |= pre & suf;
        }

        int ans = 0;
        for (int mask : has) {
            ans += Integer.bitCount(mask);
        }
        return ans;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    int countPalindromicSubsequence(string s) {
        int n = s.size();
        int suf_cnt[26]{}; // 统计后缀每个字母的个数
        int suf = 0;
        for (int i = 1; i < n; i++) {
            int ch = s[i] - 'a';
            suf_cnt[ch]++;
            suf |= 1 << ch;
        }

        int pre = 0;
        int has[26]{};
        for (int i = 1; i < n - 1; i++) {
            pre |= 1 << (s[i - 1] - 'a');
            int ch = s[i] - 'a';
            suf_cnt[ch]--;
            if (suf_cnt[ch] == 0) { // 现在，后缀 [i+1,n-1] 不包含字母 ch
                suf ^= 1 << ch; // 从 suf 中去掉 ch
            }
            has[ch] |= pre & suf;
        }

        int ans = 0;
        for (int mask : has) {
            ans += popcount((uint32_t) mask);
        }
        return ans;
    }
};
```

```go [sol-Go]
func countPalindromicSubsequence(s string) (ans int) {
	n := len(s)
	sufCnt := [26]int{} // 统计后缀每个字母的个数
	suf := 0
	for _, ch := range s[1:] {
		ch -= 'a'
		sufCnt[ch]++
		suf |= 1 << ch
	}

	pre := 0
	has := [26]int{}
	for i := 1; i < n-1; i++ {
		pre |= 1 << (s[i-1] - 'a')
		ch := s[i] - 'a'
		sufCnt[ch]--
		if sufCnt[ch] == 0 { // 现在，后缀 [i+1,n-1] 不包含字母 ch
			suf ^= 1 << ch // 从 suf 中去掉 ch
		}
		has[ch] |= pre & suf
	}

	for _, mask := range has {
		ans += bits.OnesCount(uint(mask))
	}
	return
}
```

```js [sol-JavaScript]
var countPalindromicSubsequence = function(s) {
    const n = s.length;
    const ordA = 'a'.charCodeAt(0);
    const sufCnt = Array(26).fill(0); // 统计后缀每个字母的个数
    let suf = 0;
    for (let i = 1; i < n; i++) {
        const ch = s.charCodeAt(i) - ordA;
        sufCnt[ch]++;
        suf |= 1 << ch;
    }

    let pre = 0;
    const has = Array(26).fill(0);
    for (let i = 1; i < n - 1; i++) {
        pre |= 1 << (s.charCodeAt(i - 1) - ordA);
        const ch = s.charCodeAt(i) - ordA;
        sufCnt[ch]--;
        if (sufCnt[ch] === 0) { // 现在，后缀 [i+1,n-1] 不包含字母 ch
            suf ^= 1 << ch; // 从 suf 中去掉 ch
        }
        has[ch] |= pre & suf;
    }

    let ans = 0;
    for (const mask of has) {
        ans += bitCount32(mask);
    }
    return ans;
};

// 参考 Java 的 Integer.bitCount
function bitCount32(i) {
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
}
```

```rust [sol-Rust]
impl Solution {
    pub fn count_palindromic_subsequence(s: String) -> i32 {
        let s = s.as_bytes();
        let n = s.len();

        let mut suf_cnt = [0; 26]; // 统计后缀每个字母的个数
        let mut suf = 0;
        for &ch in &s[1..] {
            let ch = (ch - b'a') as usize;
            suf_cnt[ch] += 1;
            suf |= 1 << ch;
        }

        let mut pre = 0;
        let mut has = [0u32; 26];
        for i in 1..n - 1 {
            pre |= 1 << (s[i - 1] - b'a');
            let ch = (s[i] - b'a') as usize;
            suf_cnt[ch] -= 1;
            if suf_cnt[ch] == 0 { // 现在，后缀 [i+1,n-1] 不包含字母 ch
                suf ^= 1 << ch; // 从 suf 中去掉 ch
            }
            has[ch] |= pre & suf;
        }

        has.into_iter().map(|mask| mask.count_ones() as i32).sum()
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n + |\Sigma|)$，其中 $n$ 是 $s$ 的长度，$|\Sigma|=26$ 是字符集合的大小。
- 空间复杂度：$\mathcal{O}(|\Sigma|)$。

## 专题训练

1. 数据结构题单的「**§0.2 枚举中间**」。
2. 动态规划题单的「**专题：前后缀分解**」。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
