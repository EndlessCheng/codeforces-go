类似 [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)，连续相同的字母异位词，只保留其中最左边的。

示例 1 的 $\texttt{abba},\texttt{baba},\texttt{bbaa}$ 互为字母异位词，保留最左边的 $\texttt{abba}$；$\texttt{cd},\texttt{cd}$ 互为字母异位词，保留最左边的 $\texttt{cd}$。

根据题意，如果两个字符串每种字母的出现次数相同，就是一对字母异位词。可以用哈希表统计字母出现次数，也可以把字符串排序，两个排序后相同的字符串是一对字母异位词。

其余逻辑同 26 题，见 [我的题解](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solutions/2807162/gen-zhao-wo-guo-yi-bian-shi-li-2ni-jiu-m-rvyk/)。

```py [sol-Py3]
class Solution:
    def removeAnagrams(self, words: List[str]) -> List[str]:
        k = 1
        for s, t in pairwise(words):
            if sorted(s) != sorted(t):
                words[k] = t
                k += 1
        del words[k:]
        return words
```

```py [sol-Py3 写法二]
class Solution:
    def removeAnagrams(self, words: List[str]) -> List[str]:
        k = 1
        for s, t in pairwise(words):
            if Counter(s) != Counter(t):
                words[k] = t
                k += 1
        del words[k:]
        return words
```

```java [sol-Java]
class Solution {
    public List<String> removeAnagrams(String[] words) {
        char[] base = words[0].toCharArray();
        Arrays.sort(base);
        int k = 1;
        for (int i = 1; i < words.length; i++) {
            char[] s = words[i].toCharArray();
            Arrays.sort(s);
            if (!Arrays.equals(s, base)) {
                base = s;
                words[k++] = words[i]; // 保留 words[i]
            }
        }
        return Arrays.asList(Arrays.copyOf(words, k));
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    vector<string> removeAnagrams(vector<string>& words) {
        string base = "";
        int k = 0;
        for (auto& word : words) {
            string s = word;
            ranges::sort(s);
            if (s != base) {
                base = move(s);
                words[k++] = word; // 保留 word
            }
        }
        words.resize(k);
        return words;
    }
};
```

```c [sol-C]
int cmp(const void* a, const void* b) {
    return (*(char*)a - *(char*)b);
}

char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){
    char* base = strdup(words[0]);
    qsort(base, strlen(base), sizeof(char), cmp);
    int k = 1;
    for (int i = 1; i < wordsSize; i++) {
        char* s = strdup(words[i]);
        qsort(s, strlen(s), sizeof(char), cmp);
        if (strcmp(s, base)) {
            free(base);
            base = s;
            words[k++] = words[i]; // 保留 words[i]
        } else {
            free(s);
        }
    }
    free(base);
    *returnSize = k;
    return words;
}
```

```go [sol-Go]
func removeAnagrams(words []string) []string {
	var base []byte
	k := 0
	for _, word := range words {
		s := []byte(word)
		slices.Sort(s)
		if !bytes.Equal(s, base) {
			base = s
			words[k] = word // 保留 word
			k++
		}
	}
	return words[:k]
}
```

```js [sol-JavaScript]
var removeAnagrams = function(words) {
    let base = '';
    let k = 0;
    for (const word of words) {
        const s = word.split('').sort().join('');
        if (s !== base) {
            base = s;
            words[k++] = word; // 保留 word
        }
    }
    words.length = k;
    return words;
};
```

```rust [sol-Rust]
impl Solution {
    pub fn remove_anagrams(mut words: Vec<String>) -> Vec<String> {
        let mut base = vec![];
        let mut k = 0;
        for i in 0..words.len() {
            let mut s = words[i].as_bytes().to_vec();
            s.sort_unstable();
            if s != base {
                base = s;
                words[k] = words[i].clone(); // 保留 words[i]
                k += 1;
            }
        }
        words.truncate(k);
        words
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(nL)$ 或者 $\mathcal{O}(nL\log L)$，其中 $n$ 是 $\textit{words}$ 的长度，$L\le 10$ 是 $\textit{words}[i]$ 的最大长度。
- 空间复杂度：$\mathcal{O}(L)$。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、二叉树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA/一般树）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
