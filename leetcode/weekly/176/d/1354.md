## 思路

倒着想，最后一步发生了什么？

由于每次操作得到的元素和会越来越大，所以 $\textit{target}$ 的最大值就是最后一步操作的元素和。

示例 1 的 $\textit{target}=[9,3,5]$。

- 最后一步，最大值为 $9$，说明操作之前所有元素和等于 $9$。也就是操作之前 $\textit{target}[0]+3+5 = 9$，解得操作之前 $\textit{target}[0] = 1$。
- 现在 $\textit{target}=[1,3,5]$，继续倒推，操作之前 $\textit{target}[2] +1+3 = 5$，解得操作之前 $\textit{target}[2] = 1$。
- 现在 $\textit{target}=[1,3,1]$，继续倒推，操作之前 $\textit{target}[1] +1+1 = 3$，解得操作之前 $\textit{target}[1] = 1$。
- 现在 $\textit{target}=[1,1,1]$，即初始数组。这说明我们可以通过操作初始数组得到目标数组。

在上面的过程中，我们需要：

1. 快速找到当前 $\textit{target}$ 的最大值，这可以用**最大堆**维护。
2. 快速计算除了 $\max(\textit{target})$ 以外的其余元素和，这可以用一个变量 $\textit{sum}$ 维护。

## 细节

如果最大值 $x = 100$，但其余元素之和只有 $\textit{sum} = 3$，那么 $100-3=97$，由于 $97>3$，新得到的数字 $97$ 比其余元素之和还要大，必然还是 $\textit{target}$ 的最大值。我们会把这个最大值反复地减去 $3$，直到 $\le 3$ 为止。

$$
100\to 97\to 94\to 91\to\cdots \to 4\to 1
$$

这太慢了。注意到上式与取模是类似的，即 $100\bmod 3 = 1$。

一般地，由于目标是把 $x$ 减少到 $\le \textit{sum}$ 为止（不能减成 $0$ 或者负数），也就是计算

$$
\begin{cases} 
x\bmod \textit{sum}, & x\bmod \textit{sum} > 0     \\
\textit{sum}, & x\bmod \textit{sum} = 0     \\
\end{cases}
$$

这等价于

$$
(x - 1) \bmod \textit{sum} + 1
$$

## 答疑

**问**：我们把 $x$ 更新成了一个 $\le \textit{sum}$ 的数，但 $x$ 仍可能是 $\textit{target}$ 的最大值，这种情况怎么办？

**答**：有两种情况。第一种情况是更新后的数组全为 $1$，比如 $[1,1,1]$，$x$ 虽然是 $\textit{target}$ 的最大值，但我们可以跳出循环了。第二种情况是更新后的数组不全为 $1$，比如 $[2,1,1,1]$，那么下一轮循环我们一定会返回 $\texttt{false}$。

```py [sol-Python3]
class Solution:
    def isPossible(self, target: List[int]) -> bool:
        s = sum(target)
        h = [-x for x in target]  # 取相反数，变成最大堆
        heapify(h)

        # 如果最大值等于 1，说明所有数都等于 1
        while -h[0] > 1:
            x = -h[0]
            s -= x  # 减去 x 后，s 为其余元素之和

            # s 不能是 0，这意味着 target 只有一个数且这个数大于 1
            # x 减去 s 后必须是正数
            if s == 0 or x <= s:
                return False

            # 把 x 多次减去 s，直到 x <= s 为止
            # 也就是计算 x%s，但如果 x%s == 0 则调整为 s
            x = (x - 1) % s + 1
            s += x
            heapreplace(h, -x)

        return True
```

```java [sol-Java]
class Solution {
    public boolean isPossible(int[] target) {
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        long sum = 0;
        for (int x : target) {
            pq.offer(x);
            sum += x;
        }

        // 如果最大值等于 1，说明所有数都等于 1
        while (pq.peek() > 1) {
            int x = pq.poll();
            sum -= x; // 减去 x 后，sum 为其余元素之和

            // sum 不能是 0，这意味着 target 只有一个数且这个数大于 1
            // x 减去 sum 后必须是正数
            if (sum == 0 || x <= sum) {
                return false;
            }

            // 把 x 多次减去 sum，直到 x <= sum 为止
            // 也就是计算 x%sum，但如果 x%sum == 0 则调整为 sum
            x = (x - 1) % (int) sum + 1;
            sum += x;
            pq.offer(x);
        }

        return true;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    bool isPossible(vector<int>& target) {
        long long sum = reduce(target.begin(), target.end(), 0LL);
        priority_queue<int> pq(target.begin(), target.end());

        // 如果最大值等于 1，说明所有数都等于 1
        while (pq.top() > 1) {
            int x = pq.top();
            pq.pop();
            sum -= x; // 减去 x 后，sum 为其余元素之和

            // sum 不能是 0，这意味着 target 只有一个数且这个数大于 1
            // x 减去 sum 后必须是正数
            if (sum == 0 || x <= sum) {
                return false;
            }

            // 把 x 多次减去 sum，直到 x <= sum 为止
            // 也就是计算 x%sum，但如果 x%sum == 0 则调整为 sum
            x = (x - 1) % sum + 1;
            sum += x;
            pq.push(x);
        }

        return true;
    }
};
```

```go [sol-Go]
func isPossible(target []int) bool {
	sum := 0
	for _, x := range target {
		sum += x
	}

	h := hp{target}
	heap.Init(&h)

	// 如果最大值等于 1，说明所有数都等于 1
	for h.IntSlice[0] > 1 {
		x := h.IntSlice[0]
		sum -= x // 减去 x 后，sum 为其余元素之和

		// sum 不能是 0，这意味着 target 只有一个数且这个数大于 1
		// x 减去 sum 后必须是正数
		if sum == 0 || x <= sum {
			return false
		}

		// 把 x 多次减去 sum，直到 x <= sum 为止
		// 也就是计算 x%sum，但如果 x%sum == 0 则调整为 sum
		x = (x-1)%sum + 1
		sum += x
		h.IntSlice[0] = x
		heap.Fix(&h, 0)
	}

	return true
}

type hp struct{ sort.IntSlice }
func (h hp) Less(i, j int) bool { return h.IntSlice[i] > h.IntSlice[j] }
func (hp) Push(any)             {} // 没用到，无需实现
func (hp) Pop() (_ any)         { return }
```

```js [sol-JavaScript]
var isPossible = function(target) {
    let sum = _.sum(target);
    const pq = new MaxPriorityQueue();
    for (const x of target) {
        pq.enqueue(x);
    }

    // 如果最大值等于 1，说明所有数都等于 1
    while (pq.front() > 1) {
        let x = pq.dequeue();
        sum -= x; // 减去 x 后，sum 为其余元素之和

        // sum 不能是 0，这意味着 target 只有一个数且这个数大于 1
        // x 减去 sum 后必须是正数
        if (sum === 0 || x <= sum) {
            return false;
        }

        // 把 x 多次减去 sum，直到 x <= sum 为止
        // 也就是计算 x%sum，但如果 x%sum == 0 则调整为 sum
        x = (x - 1) % sum + 1;
        sum += x;
        pq.enqueue(x);
    }

    return true;
};
```

```rust [sol-Rust]
use std::collections::BinaryHeap;

impl Solution {
    pub fn is_possible(target: Vec<i32>) -> bool {
        let mut sum = target.iter().map(|&x| x as i64).sum();
        let mut pq = BinaryHeap::from(target); // 原地 O(n) 堆化

        // 如果最大值等于 1，说明所有数都等于 1
        while *pq.peek().unwrap() > 1 {
            let x = pq.pop().unwrap() as i64;
            sum -= x; // 减去 x 后，sum 为其余元素之和

            // sum 不能是 0，这意味着 target 只有一个数且这个数大于 1
            // x 减去 sum 后必须是正数
            if sum == 0 || x <= sum {
                return false;
            }

            // 把 x 多次减去 sum，直到 x <= sum 为止
            // 也就是计算 x%sum，但如果 x%sum == 0 则调整为 sum
            let x = (x - 1) % sum + 1;
            sum += x;
            pq.push(x as i32);
        }

        true
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n + \log S\cdot \log n)$ 或者 $\mathcal{O}(n\log n + \log S\cdot \log n)$，其中 $n$ 是 $\textit{target}$ 的长度，$S$ 是 $\textit{target}$ 的元素和。瓶颈在建堆上，可以做到 $\mathcal{O}(n)$ 堆化。至于后面的循环，设最大值为 $x$，其余元素和为 $r$。如果循环能继续跑下去，那么 $x>r$，所以 $S=x+r > 2r$，即 $r< \dfrac{S}{2}$。此外，下一轮循环的最大值 $x'\le r < \dfrac{S}{2}$，同时 $x'$ 又是下下一轮循环的元素和，所以两轮循环之后 $S'' < \dfrac{S}{2}$。所以只会循环 $\mathcal{O}(\log S)$ 次，每次 $\mathcal{O}(\log n)$ 操作堆。所以时间复杂度瓶颈其实在建堆上，后面的循环只有 $\mathcal{O}(\log S\cdot \log n)$。
- 空间复杂度：$\mathcal{O}(1)$ 或 $\mathcal{O}(n)$。取决于是否原地堆化。

## 专题训练

1. 数据结构题单的「**五、堆（优先队列）**」。
2. 贪心与思维题单的「**§5.3 逆向思维**」。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
