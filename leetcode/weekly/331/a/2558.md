## 思路

维护一些数的最大值，可以**最大堆**模拟。

循环 $k$ 次。每次循环，弹出堆顶 $\textit{top}$，然后把 $\left\lfloor\sqrt{\textit{top}}\right\rfloor$ 入堆。

循环结束后，堆中所有元素之和就是答案。

## 优化

1. 如果堆顶等于 $1$，说明堆中所有元素都为 $1$。由于 $\sqrt{1} = 1$，后续操作无法修改任何元素，可以直接退出循环。
2. 原地堆化（heapify）可以做到 $\mathcal{O}(1)$ 的空间复杂度。部分语言用的标准库自带的堆化函数。关于堆化是如何实现的，可以看下面的 Java 代码。

```py [sol-Python3]
class Solution:
    def pickGifts(self, gifts: List[int], k: int) -> int:
        heapify_max(gifts)  # 原地堆化
        while k and gifts[0] > 1:
            heapreplace_max(gifts, isqrt(gifts[0]))  # 直接修改堆顶
            k -= 1
        return sum(gifts)
```

```java [sol-Java]
class Solution {
    public long pickGifts(int[] gifts, int k) {
        heapify(gifts); // 原地堆化（最大堆）
        while (k-- > 0 && gifts[0] > 1) {
            gifts[0] = (int) Math.sqrt(gifts[0]); // 直接修改堆顶
            sink(gifts, 0); // 堆化（只需要把 gifts[0] 下沉）
        }

        long ans = 0;
        for (int x : gifts) {
            ans += x;
        }
        return ans;
    }

    // 原地堆化（最大堆）
    // 堆化可以保证 h[0] 是堆顶元素，且 h[i] >= max(h[2*i+1], h[2*i+2])
    private void heapify(int[] h) {
        // 倒着遍历，从而保证 i 的左右子树一定是堆，那么 sink(h, i) 就可以把左右子树合并成一个堆
        // 下标 >= h.length / 2 的元素是二叉树的叶子，无需下沉
        for (int i = h.length / 2 - 1; i >= 0; i--) {
            sink(h, i);
        }
    }

    // 把 h[i] 不断下沉，每次找左右儿子中最大的交换，直到 i 的左右儿子都 <= h[i] 时停止
    private void sink(int[] h, int i) {
        int n = h.length;
        while (2 * i + 1 < n) {
            int j = 2 * i + 1; // i 的左儿子
            if (j + 1 < n && h[j + 1] > h[j]) { // i 的右儿子比 i 的左儿子大
                j++;
            }
            if (h[j] <= h[i]) { // 说明 i 的左右儿子都 <= h[i]，停止下沉
                break;
            }
            swap(h, i, j); // 下沉
            i = j;
        }
    }

    // 交换 h[i] 和 h[j]
    private void swap(int[] h, int i, int j) {
        int tmp = h[i];
        h[i] = h[j];
        h[j] = tmp;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    long long pickGifts(vector<int> &gifts, int k) {
        make_heap(gifts.begin(), gifts.end()); // 原地堆化（最大堆）
        while (k-- && gifts[0] > 1) {
            pop_heap(gifts.begin(), gifts.end()); // 弹出堆顶并移到末尾
            gifts.back() = sqrt(gifts.back());
            push_heap(gifts.begin(), gifts.end()); // 把末尾元素入堆
        }
        return accumulate(gifts.begin(), gifts.end(), 0LL);
    }
};
```

```go [sol-Go]
func pickGifts(gifts []int, k int) (ans int64) {
    h := &hp{gifts}
    heap.Init(h) // 原地堆化
    for ; k > 0 && gifts[0] > 1; k-- {
        gifts[0] = int(math.Sqrt(float64(gifts[0]))) // 直接修改堆顶
        heap.Fix(h, 0)
    }
    for _, x := range gifts {
        ans += int64(x)
    }
    return
}

type hp struct{ sort.IntSlice }
func (h hp) Less(i, j int) bool { return h.IntSlice[i] > h.IntSlice[j] } // 最大堆
func (hp) Pop() (_ any)         { return }
func (hp) Push(any)             {}
```

```js [sol-JavaScript]
var pickGifts = function (gifts, k) {
    heapify(gifts); // 堆化
    while (k--) {
        gifts[0] = Math.floor(Math.sqrt(gifts[0])); // 直接修改堆顶
        sink(gifts, 0); // 堆化（只需要把 gifts[0] 下沉）
    }
    return _.sum(gifts);
};

// 原地堆化（最大堆）
// 堆化可以保证 h[0] 是堆顶元素，且 h[i] >= max(h[2*i+1], h[2*i+2])
function heapify(h) {
    // 倒着遍历，从而保证 i 的左右子树一定是堆，那么 sink(h, i) 就可以把左右子树合并成一个堆
    // 下标 >= h.length / 2 的元素是二叉树的叶子，无需下沉
    for (let i = Math.floor(h.length / 2) - 1; i >= 0; i--) {
        sink(h, i);
    }
}

// 把 h[i] 不断下沉，直到 i 的左右儿子都 <= h[i]
function sink(h, i) {
    const n = h.length;
    while (2 * i + 1 < n) {
        let j = 2 * i + 1; // i 的左儿子
        if (j + 1 < n && h[j + 1] > h[j]) { // i 的右儿子比 i 的左儿子大
            j++;
        }
        if (h[j] <= h[i]) { // 说明 i 的左右儿子都 <= h[i]，停止下沉
            break;
        }
        [h[i], h[j]] = [h[j], h[i]]; // 下沉
        i = j;
    }
}
```

```rust [sol-Rust]
use std::collections::BinaryHeap;

impl Solution {
    pub fn pick_gifts(gifts: Vec<i32>, k: i32) -> i64 {
        let mut h = BinaryHeap::from(gifts); // 原地堆化（最大堆）
        for _ in 0..k {
            let top = h.pop().unwrap();
            h.push((top as f64).sqrt() as i32);
            if *h.peek().unwrap() == 1 {
                break;
            }
        }
        h.iter().map(|&x| x as i64).sum()
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n + k\log n)$，其中 $n$ 为 $\textit{gifts}$ 的长度。堆化需要 $\mathcal{O}(n)$ 的时间（证明见下）。每次修改堆顶，需要 $\mathcal{O}(\log n)$ 的时间。计算平方根有专门的 CPU 指令，可以视为 $\mathcal{O}(1)$ 时间。所以总的时间复杂度为 $\mathcal{O}(n + k\log n)$。
- 空间复杂度：$\mathcal{O}(1)$。

#### 关于堆化的时间复杂度

从 Java 代码的实现上看，堆化（heapify）的时间复杂度「似乎」是 $\mathcal{O}(n\log n)$ 的，果真如此吗？注意堆中大部分节点都集中在下层，`sink` 中的循环没几次就结束了。假设堆是一棵满二叉树，那么倒数第二层有 $\left\lceil\dfrac{n}{4}\right\rceil$ 个节点，这些节点在 `sink` 中至多循环一次。倒数第三层有 $\left\lceil\dfrac{n}{8}\right\rceil$ 个节点，这些节点在 `sink` 中至多循环两次。依此类推，总的循环次数至多为

$$
\left\lceil\dfrac{n}{2^2}\right\rceil\cdot 1 + \left\lceil\dfrac{n}{2^3}\right\rceil\cdot 2 + \left\lceil\dfrac{n}{2^4}\right\rceil\cdot 3 + \cdots + \left\lceil\dfrac{n}{2^{k+1}}\right\rceil\cdot k
$$

其中 $k = \left\lfloor\log_2{n}\right\rfloor$。

在计算大 $\mathcal{O}$ 记号时，上取整符号可以忽略，从而得到

$$
\mathcal{O}\left(n\cdot\left(\dfrac{1}{2^2} + \dfrac{2}{2^3} + \cdots + \dfrac{k}{2^{k+1}}\right)\right)
$$

设 

$$
S = \dfrac{1}{2^2} + \dfrac{2}{2^3} +  \dfrac{3}{2^4} + \cdots + \dfrac{k}{2^{k+1}}
$$

那么

$$
2S = \dfrac{1}{2} + \dfrac{2}{2^2} + \dfrac{3}{2^3}\cdots + \dfrac{k}{2^k}
$$

所以

$$
S = 2S - S = \dfrac{1}{2} + \dfrac{1}{2^2} + \dfrac{1}{2^3} + \cdots + \dfrac{1}{2^k} - \dfrac{k}{2^{k+1}} < 1- \dfrac{k}{2^{k+1}} < 1
$$

所以堆化的时间复杂度为 $\mathcal{O}(n)$。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
