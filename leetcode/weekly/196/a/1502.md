## 方法一：排序

由于等差数列一定是有序的，所以先把 $\textit{arr}$ 排序。

排序后，公差 $d = \textit{arr}[1] - \textit{arr}[0]$。

检查其余相邻元素是否均满足 $\textit{arr}[i] - \textit{arr}[i-1] = d$。

```py [sol-Python3]
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr.sort()
        d = arr[1] - arr[0]  # 公差
        return all(y - x == d for x, y in pairwise(arr))
```

```java [sol-Java]
class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int d = arr[1] - arr[0]; // 公差
        for (int i = 2; i < arr.length; i++) {
            if (arr[i] - arr[i - 1] != d) {
                return false;
            }
        }
        return true;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    bool canMakeArithmeticProgression(vector<int>& arr) {
        ranges::sort(arr);
        int d = arr[1] - arr[0]; // 公差
        for (int i = 2; i < arr.size(); i++) {
            if (arr[i] - arr[i - 1] != d) {
                return false;
            }
        }
        return true;
    }
};
```

```go [sol-Go]
func canMakeArithmeticProgression(arr []int) bool {
	slices.Sort(arr)
	d := arr[1] - arr[0] // 公差
	for i := 2; i < len(arr); i++ {
		if arr[i]-arr[i-1] != d {
			return false
		}
	}
	return true
}
```

```js [sol-JavaScript]
var canMakeArithmeticProgression = function(arr) {
    arr.sort((a, b) => a - b);
    const d = arr[1] - arr[0]; // 公差
    for (let i = 2; i < arr.length; i++) {
        if (arr[i] - arr[i - 1] !== d) {
            return false;
        }
    }
    return true;
};
```

```rust [sol-Rust]
impl Solution {
    pub fn can_make_arithmetic_progression(mut arr: Vec<i32>) -> bool {
        arr.sort_unstable();
        let d = arr[1] - arr[0]; // 公差
        for i in 2..arr.len() {
            if arr[i] - arr[i - 1] != d {
                return false;
            }
        }
        true
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n\log n)$，其中 $n$ 是 $\textit{arr}$ 的长度。瓶颈在排序上。
- 空间复杂度：$\mathcal{O}(1)$。忽略排序的栈开销。

## 方法二：从公差入手

设 $m$ 和 $M$ 分别是 $\textit{arr}$ 的最小值和最大值。

如果 $\textit{arr}$ 可以重排成等差数列，那么 $M = m + (n-1)\cdot d$，解得公差为

$$
d = \dfrac{M-m}{n-1}
$$

如果 $M-m$ 不是 $n-1$ 的倍数，那么 $d$ 不是整数，返回 $\texttt{false}$。

否则，等差数列为

$$
m, m+d,m+2d,\ldots,M
$$

检查这 $n$ 个数是否都在 $\textit{arr}$ 中。

把 $\textit{arr}$ 转成哈希集合，加速判断。

特殊情况：如果 $m=M$，那么 $\textit{arr}$ 所有元素都相等，是公差为 $0$ 的等差数列。

### 优化前

```py [sol-Python3]
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        mn, mx = min(arr), max(arr)
        if mn == mx:  # 特殊情况：公差为 0 的等差数列
            return True

        d, r = divmod(mx - mn, len(arr) - 1)
        if r:  # 公差 d 必须是整数
            return False

        st = set(arr)
        # 检查 mn, mn+d, mn+2d, ..., mx 每个数是否都存在（注意这一共有 n 个数）
        # mn 和 mx 已经有无需检查
        return all(x in st for x in range(mn + d, mx, d)) 
```

```java [sol-Java]
class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        int mn = Integer.MAX_VALUE;
        int mx = Integer.MIN_VALUE;
        Set<Integer> set = new HashSet<>();
        for (int x : arr) {
            set.add(x);
            mn = Math.min(mn, x);
            mx = Math.max(mx, x);
        }
        if (mn == mx) { // 特殊情况：公差为 0 的等差数列
            return true;
        }

        if ((mx - mn) % (arr.length - 1) > 0) { // 公差必须是整数
            return false;
        }
        int d = (mx - mn) / (arr.length - 1); // 公差

        // 检查 mn, mn+d, mn+2d, ..., mx 每个数是否都存在（注意这一共有 n 个数）
        // mn 和 mx 已经有无需检查
        for (int x = mn + d; x < mx; x += d) {
            if (!set.contains(x)) {
                return false;
            }
        }
        return true;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    bool canMakeArithmeticProgression(vector<int>& arr) {
        auto [mn, mx] = ranges::minmax(arr);
        if (mn == mx) { // 特殊情况：公差为 0 的等差数列
            return true;
        }

        if ((mx - mn) % (arr.size() - 1)) { // 公差必须是整数
            return false;
        }
        int d = (mx - mn) / (arr.size() - 1); // 公差

        unordered_set<int> st(arr.begin(), arr.end());
        // 检查 mn, mn+d, mn+2d, ..., mx 每个数是否都存在（注意这一共有 n 个数）
        // mn 和 mx 已经有无需检查
        for (int x = mn + d; x < mx; x += d) {
            if (!st.contains(x)) {
                return false;
            }
        }
        return true;
    }
};
```

```go [sol-Go]
func canMakeArithmeticProgression(arr []int) bool {
	mx := slices.Max(arr)
	mn := slices.Min(arr)
	if mn == mx { // 特殊情况：公差为 0 的等差数列
		return true
	}

	if (mx-mn)%(len(arr)-1) > 0 { // 公差必须是整数
		return false
	}
	d := (mx - mn) / (len(arr) - 1) // 公差

	has := map[int]bool{}
	for _, x := range arr {
		has[x] = true
	}
	// 检查 mn, mn+d, mn+2d, ..., mx 每个数是否都存在（注意这一共有 n 个数）
	// mn 和 mx 已经有无需检查
	for x := mn + d; x < mx; x += d {
		if !has[x] {
			return false
		}
	}
	return true
}
```

```js [sol-JavaScript]
var canMakeArithmeticProgression = function(arr) {
    const mn = Math.min(...arr);
    const mx = Math.max(...arr);
    if (mn === mx) { // 特殊情况：公差为 0 的等差数列
        return true;
    }

    if ((mx - mn) % (arr.length - 1) > 0) { // 公差必须是整数
        return false;
    }
    const d = (mx - mn) / (arr.length - 1); // 公差

    const st = new Set(arr);
    // 检查 mn, mn+d, mn+2d, ..., mx 每个数是否都存在（注意这一共有 n 个数）
    // mn 和 mx 已经有无需检查
    for (let x = mn + d; x < mx; x += d) {
        if (!st.has(x)) {
            return false;
        }
    }
    return true;
};
```

```rust [sol-Rust]
use std::collections::HashSet;

impl Solution {
    pub fn can_make_arithmetic_progression(arr: Vec<i32>) -> bool {
        let mn = *arr.iter().min().unwrap();
        let mx = *arr.iter().max().unwrap();
        if mn == mx { // 特殊情况：公差为 0 的等差数列
            return true;
        }

        let k = (arr.len() - 1) as i32;
        if (mx - mn) % k > 0 { // 公差必须是整数
            return false;
        }
        let d = (mx - mn) / k; // 公差

        let st = arr.into_iter().collect::<HashSet<_>>();
        // 检查 mn, mn+d, mn+2d, ..., mx 每个数是否都存在（注意这一共有 n 个数）
        // mn 和 mx 已经有无需检查
        (mn + d..mx).step_by(d as usize).all(|x| st.contains(&x))
    }
}
```

### 优化

对于等差数列

$$
m, m+d,m+2d,\ldots,M
$$

每个数可以看成 $m + k\cdot d$。

如果 $k = 0,1,2,\ldots,n-1$ 各恰好出现一次，那么 $\textit{arr}$ 可以重排成等差数列。

遍历 $\textit{arr}$，如果 $\textit{arr}[i] = m + k\cdot d$，那么

$$
k = \dfrac{\textit{arr}[i] - m}{d}
$$

所以 $\textit{arr}[i] - m$ 必须是 $d$ 的倍数。

用一个长为 $n$ 的布尔数组记录每个 $k$ 是否遇到过，从而判断是否有重复的 $k$。

```py [sol-Python3]
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        mn, mx = min(arr), max(arr)
        if mn == mx:  # 特殊情况：公差为 0 的等差数列
            return True

        n = len(arr)
        d, r = divmod(mx - mn, n - 1)
        if r:  # 公差 d 必须是整数
            return False

        has = [False] * n
        for x in arr:
            k, r = divmod(x - mn, d)
            if r or has[k]:  # k 不是整数或者之前遇到过
                return False
            has[k] = True
        return True
```

```java [sol-Java]
class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        int mn = Integer.MAX_VALUE;
        int mx = Integer.MIN_VALUE;
        for (int x : arr) {
            mn = Math.min(mn, x);
            mx = Math.max(mx, x);
        }
        if (mn == mx) { // 特殊情况：公差为 0 的等差数列
            return true;
        }

        int n = arr.length;
        if ((mx - mn) % (n - 1) > 0) { // 公差必须是整数
            return false;
        }
        int d = (mx - mn) / (n - 1); // 公差

        boolean[] has = new boolean[n];
        for (int x : arr) {
            int k = (x - mn) / d;
            if ((x - mn) % d > 0 || has[k]) { // k 不是整数或者之前遇到过
                return false;
            }
            has[k] = true;
        }
        return true;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    bool canMakeArithmeticProgression(vector<int>& arr) {
        auto [mn, mx] = ranges::minmax(arr);
        if (mn == mx) { // 特殊情况：公差为 0 的等差数列
            return true;
        }

        int n = arr.size();
        if ((mx - mn) % (n - 1)) { // 公差必须是整数
            return false;
        }
        int d = (mx - mn) / (n - 1); // 公差

        vector<int8_t> has(n);
        for (int x : arr) {
            int k = (x - mn) / d;
            if ((x - mn) % d || has[k]) { // k 不是整数或者之前遇到过
                return false;
            }
            has[k] = true;
        }
        return true;
    }
};
```

```go [sol-Go]
func canMakeArithmeticProgression(arr []int) bool {
	mx := slices.Max(arr)
	mn := slices.Min(arr)
	if mn == mx { // 特殊情况：公差为 0 的等差数列
		return true
	}

	n := len(arr)
	if (mx-mn)%(n-1) > 0 { // 公差必须是整数
		return false
	}
	d := (mx - mn) / (n - 1) // 公差

	has := make([]bool, n)
	for _, x := range arr {
		k := (x - mn) / d
		if (x-mn)%d > 0 || has[k] { // k 不是整数或者之前遇到过
			return false
		}
		has[k] = true
	}
	return true
}
```

```js [sol-JavaScript]
var canMakeArithmeticProgression = function(arr) {
    const mn = Math.min(...arr);
    const mx = Math.max(...arr);
    if (mn === mx) { // 特殊情况：公差为 0 的等差数列
        return true;
    }

    const n = arr.length;
    if ((mx - mn) % (n - 1) > 0) { // 公差必须是整数
        return false;
    }
    const d = (mx - mn) / (n - 1); // 公差

    const has = Array(n).fill(false);
    for (const x of arr) {
        const k = (x - mn) / d;
        if ((x - mn) % d > 0 || has[k]) { // k 不是整数或者之前遇到过
            return false;
        }
        has[k] = true;
    }
    return true;
};
```

```rust [sol-Rust]
impl Solution {
    pub fn can_make_arithmetic_progression(arr: Vec<i32>) -> bool {
        let mn = *arr.iter().min().unwrap();
        let mx = *arr.iter().max().unwrap();
        if mn == mx { // 特殊情况：公差为 0 的等差数列
            return true;
        }

        let n = arr.len();
        if (mx - mn) % (n as i32 - 1) != 0 { // 公差必须是整数
            return false;
        }
        let d = (mx - mn) / (n as i32 - 1); // 公差

        let mut has = vec![false; n];
        for x in arr {
            let k = ((x - mn) / d) as usize;
            if (x - mn) % d > 0 || has[k] { // k 不是整数或者之前遇到过
                return false;
            }
            has[k] = true;
        }
        true
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n)$，其中 $n$ 是 $\textit{arr}$ 的长度。
- 空间复杂度：$\mathcal{O}(n)$。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
