## 方法一：BFS

本题需要计算每一层的节点值之和，适合用 **BFS**。[原理讲解【基础算法精讲 13】](https://www.bilibili.com/video/BV1hG4y1277i/)。

维护两个信息：最大层和 $\textit{maxSum}$，以及对应的层号 $\textit{ans}$。如果当前层的和大于 $\textit{maxSum}$，那么更新 $\textit{maxSum}$ 和 $\textit{ans}$。

```py [sol-Python3]
class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        max_sum = -inf
        ans = 0

        q = [root]
        level = 1
        while q:
            tmp = q
            q = []
            s = 0
            for node in tmp:
                s += node.val
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)

            if s > max_sum:
                max_sum = s
                ans = level

            level += 1

        return ans
```

```java [sol-Java]
class Solution {
    public int maxLevelSum(TreeNode root) {
        int max_sum = Integer.MIN_VALUE;
        int ans = 0;

        List<TreeNode> q = new ArrayList<>();
        q.add(root);

        for (int level = 1; !q.isEmpty(); level++) {
            List<TreeNode> tmp = q;
            q = new ArrayList<>();
            int s = 0;

            for (TreeNode node : tmp) {
                s += node.val;
                if (node.left != null) {
                    q.add(node.left);
                }
                if (node.right != null) {
                    q.add(node.right);
                }
            }

            if (s > max_sum) {
                max_sum = s;
                ans = level;
            }
        }

        return ans;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        int max_sum = INT_MIN;
        int ans = 0;

        vector<TreeNode*> q = {root};
        for (int level = 1; !q.empty(); level++) {
            auto tmp = q;
            q.clear();
            int s = 0;

            for (auto node : tmp) {
                s += node->val;
                if (node->left) {
                    q.push_back(node->left);
                }
                if (node->right) {
                    q.push_back(node->right);
                }
            }

            if (s > max_sum) {
                max_sum = s;
                ans = level;
            }
        }

        return ans;
    }
};
```

```go [sol-Go]
func maxLevelSum(root *TreeNode) (ans int) {
	maxSum := math.MinInt
	q := []*TreeNode{root}

	for level := 1; q != nil; level++ {
		tmp := q
		q = nil
		s := 0

		for _, node := range tmp {
			s += node.Val
			if node.Left != nil {
				q = append(q, node.Left)
			}
			if node.Right != nil {
				q = append(q, node.Right)
			}
		}

		if s > maxSum {
			maxSum = s
			ans = level
		}
	}

	return ans
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n)$，其中 $n$ 是二叉树的节点个数。
- 空间复杂度：$\mathcal{O}(n)$。

## 方法二：DFS

创建一个列表 $\textit{rowSum}$，维护每一层的元素和。

在 DFS 的同时，把节点值加到这一层的元素和中。

最后求出最大层和对应的层号。

```py [sol-Python3]
class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        def dfs(node: Optional[TreeNode], level: int) -> None:
            if node is None:
                return

            if len(row_sum) == level:  # 首次访问 level 层
                row_sum.append(node.val)  # 节点值作为层和的初始值
            else:
                row_sum[level] += node.val

            dfs(node.left, level + 1)
            dfs(node.right, level + 1)

        row_sum = []
        dfs(root, 0)
        return row_sum.index(max(row_sum)) + 1  # 层号从 1 开始
```

```java [sol-Java]
class Solution {

    private void dfs(TreeNode node, int level, List<Integer> rowSum) {
        if (node == null) {
            return;
        }

        if (rowSum.size() == level) { // 首次访问 level 层
            rowSum.add(node.val); // 节点值作为层和的初始值
        } else {
            rowSum.set(level, rowSum.get(level) + node.val);
        }

        dfs(node.left, level + 1, rowSum);
        dfs(node.right, level + 1, rowSum);
    }

    public int maxLevelSum(TreeNode root) {
        List<Integer> rowSum = new ArrayList<>();
        dfs(root, 0, rowSum);

        int ans = 0;
        for (int i = 1; i < rowSum.size(); i++) {
            if (rowSum.get(i) > rowSum.get(ans)) {
                ans = i;
            }
        }
        return ans + 1; // 层号从 1 开始
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        vector<int> row_sum;

        auto dfs = [&](this auto&& dfs, TreeNode* node, int level) -> void {
            if (node == nullptr) {
                return;
            }

            if (row_sum.size() == level) { // 首次访问 level 层
                row_sum.push_back(node->val); // 节点值作为层和的初始值
            } else {
                row_sum[level] += node->val;
            }

            dfs(node->left, level + 1);
            dfs(node->right, level + 1);
        };

        dfs(root, 0);
        return ranges::max_element(row_sum) - row_sum.begin() + 1; // 层号从 1 开始
    }
};
```

```go [sol-Go]
func maxLevelSum(root *TreeNode) (ans int) {
	rowSum := []int{}

	var dfs func(*TreeNode, int)
	dfs = func(node *TreeNode, level int) {
		if node == nil {
			return
		}

		if len(rowSum) == level { // 首次访问 level 层
			rowSum = append(rowSum, node.Val) // 节点值作为层和的初始值
		} else {
			rowSum[level] += node.Val
		}

		dfs(node.Left, level+1)
		dfs(node.Right, level+1)
	}

	dfs(root, 0)

	for i, s := range rowSum {
		if s > rowSum[ans] {
			ans = i
		}
	}
	return ans + 1 // 层号从 1 开始
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n)$，其中 $n$ 是二叉树的节点个数。
- 空间复杂度：$\mathcal{O}(n)$。

## 专题训练

见下面树题单的「**§2.13 二叉树 BFS**」。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
