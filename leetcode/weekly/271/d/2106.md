## 核心思路

由于只能一步步地走，我们移动的范围必然是一段连续的区间。我们可以**枚举**区间的右端点，也就是往右最远摘的水果。

如果反复左右移动，会白白浪费移动次数，所以最优方案要么**先向右再向左**，要么**先向左再向右**（或者向一个方向走到底）。

设向左走最远可以到达 $\textit{fruits}[\textit{left}][0]$，其中 $\textit{left}$ 是最小的满足

$$
\textit{fruits}[\textit{left}][0]\ge \textit{startPos}-k
$$

的下标。

**枚举**区间的右端点 $\textit{right}$，也就是往右最远摘的水果为 $\textit{fruits}[\textit{right}]$。当 $\textit{right}$ 增大时，$\textit{left}$ 要么不变，要么增大，因此可以用 [滑动窗口【基础算法精讲 03】](https://www.bilibili.com/video/BV1hd4y1r7Gq/)解决。

如何判断 $\textit{left}$ 是否需要增大呢？

## 公式推导

如果先向右再向左，步数为

$$
(\textit{fruits}[\textit{right}][0] - \textit{startPos}) + (\textit{fruits}[\textit{right}][0] - \textit{fruits}[\textit{left}][0])
$$

如果先向左再向右，步数为

$$
(\textit{startPos} - \textit{fruits}[\textit{left}][0]) + (\textit{fruits}[\textit{right}][0] - \textit{fruits}[\textit{left}][0])
$$

如果上面两个式子均大于 $k$，就说明 $\textit{fruits}[\textit{left}][0]$ 太远了，无法到达，需要增大 $\textit{left}$。

移动 $\textit{left}$ 和 $\textit{right}$ 的同时，维护窗口内的水果数量 $s$，同时用 $s$ 更新答案的最大值。

注意 $\textit{right}$ 也不能太远，必须满足

$$
\textit{fruits}[\textit{right}][0]\le \textit{startPos}+k
$$

## 写法一

```py [sol-Python3]
class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        left = bisect_left(fruits, [startPos - k])  # 向左最远能到 fruits[left][0]
        right = bisect_left(fruits, [startPos + 1])  # 位置 <= startPos 的最大下标 + 1
        ans = s = sum(f[1] for f in fruits[left: right])  # 从 fruits[left][0] 到 startPos 的水果数
        # 枚举最右走到 fruits[right][0]
        while right < len(fruits) and fruits[right][0] <= startPos + k:
            s += fruits[right][1]
            while fruits[right][0] * 2 - fruits[left][0] - startPos > k and \
                  fruits[right][0] - fruits[left][0] * 2 + startPos > k:
                s -= fruits[left][1]  # fruits[left][0] 太远了
                left += 1
            ans = max(ans, s)  # 更新答案最大值
            right += 1  # 继续枚举下一个最右位置
        return ans
```

```java [sol-Java]
class Solution {
    public int maxTotalFruits(int[][] fruits, int startPos, int k) {
        int n = fruits.length;
        int left = lowerBound(fruits, startPos - k); // 向左最远能到 fruits[left][0]

        int right = left;
        // 从 fruits[left][0] 到 startPos 的水果数
        int s = 0;
        for (; right < n && fruits[right][0] <= startPos; right++) {
            s += fruits[right][1]; 
        }

        int ans = s;
        // 枚举最右走到 fruits[right][0]
        for (; right < n && fruits[right][0] <= startPos + k; right++) {
            s += fruits[right][1];
            while (fruits[right][0] * 2 - fruits[left][0] - startPos > k &&
                   fruits[right][0] - fruits[left][0] * 2 + startPos > k) {
                s -= fruits[left][1]; // fruits[left][0] 太远了
                left++;
            }
            ans = Math.max(ans, s); // 更新答案最大值
        }
        return ans;
    }

    // 见 https://www.bilibili.com/video/BV1AP41137w7/
    private int lowerBound(int[][] fruits, int target) {
        int left = -1;
        int right = fruits.length; // 开区间 (left, right)
        while (left + 1 < right) { // 开区间不为空
            // 循环不变量：
            // fruits[left][0] < target
            // fruits[right][0] >= target
            int mid = left + (right - left) / 2;
            if (fruits[mid][0] < target) {
                left = mid; // 范围缩小到 (mid, right)
            } else {
                right = mid; // 范围缩小到 (left, mid)
            }
        }
        return right;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        // 向左最远能到 fruits[left][0]
        int left = ranges::lower_bound(fruits, startPos - k, {}, [](auto& f) { return f[0]; }) - fruits.begin();

        int right = left, s = 0, n = fruits.size();
        // 从 fruits[left][0] 到 startPos 的水果数
        for (; right < n && fruits[right][0] <= startPos; right++) {
            s += fruits[right][1];
        }

        int ans = s;
        // 枚举最右走到 fruits[right][0]
        for (; right < n && fruits[right][0] <= startPos + k; right++) {
            s += fruits[right][1];
            while (fruits[right][0] * 2 - fruits[left][0] - startPos > k &&
                   fruits[right][0] - fruits[left][0] * 2 + startPos > k) {
                s -= fruits[left][1]; // fruits[left][0] 太远了
                left++;
            }
            ans = max(ans, s); // 更新答案最大值
        }
        return ans;
    }
};
```

```go [sol-Go]
func maxTotalFruits(fruits [][]int, startPos, k int) int {
	n := len(fruits)
	// 向左最远能到 fruits[left][0]
	left := sort.Search(n, func(i int) bool { return fruits[i][0] >= startPos-k })

	right, s := left, 0
	// 从 fruits[left][0] 到 startPos 的水果数
	for ; right < n && fruits[right][0] <= startPos; right++ {
		s += fruits[right][1]
	}

	ans := s
	// 枚举最右走到 fruits[right][0]
	for ; right < n && fruits[right][0] <= startPos+k; right++ {
		s += fruits[right][1] // 枚举最右位置为 fruits[right][0]
		for fruits[right][0]*2-fruits[left][0]-startPos > k &&
			fruits[right][0]-fruits[left][0]*2+startPos > k {
			s -= fruits[left][1] // fruits[left][0] 太远了
			left++
		}
		ans = max(ans, s) // 更新答案最大值
	}
	return ans
}
```

## 写法二

把第一个循环合并到第二个中。

> **注**：这会让第一个循环增加一些无效计算，运行速度可能不如上面的写法。

```py [sol-Python3]
class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        left = bisect_left(fruits, [startPos - k])  # 向左最远能到 fruits[left][0]
        ans = s = 0
        for pos, amount in fruits[left:]:
            if pos > startPos + k:
                break
            s += amount
            while pos * 2 - fruits[left][0] - startPos > k and \
                  pos - fruits[left][0] * 2 + startPos > k:
                s -= fruits[left][1]  # fruits[left][0] 太远了
                left += 1
            ans = max(ans, s)  # 更新答案最大值
        return ans
```

```java [sol-Java]
class Solution {
    public int maxTotalFruits(int[][] fruits, int startPos, int k) {
        int n = fruits.length;
        int left = lowerBound(fruits, startPos - k); // 向左最远能到 fruits[left][0]

        int ans = 0;
        int s = 0;
        // 枚举最右走到 fruits[right][0]
        for (int right = left; right < n && fruits[right][0] <= startPos + k; right++) {
            s += fruits[right][1];
            while (fruits[right][0] * 2 - fruits[left][0] - startPos > k &&
                   fruits[right][0] - fruits[left][0] * 2 + startPos > k) {
                s -= fruits[left][1]; // fruits[left][0] 太远了
                left++;
            }
            ans = Math.max(ans, s); // 更新答案最大值
        }
        return ans;
    }

    // 见 https://www.bilibili.com/video/BV1AP41137w7/
    private int lowerBound(int[][] fruits, int target) {
        int left = -1;
        int right = fruits.length; // 开区间 (left, right)
        while (left + 1 < right) { // 开区间不为空
            // 循环不变量：
            // fruits[left][0] < target
            // fruits[right][0] >= target
            int mid = left + (right - left) / 2;
            if (fruits[mid][0] < target) {
                left = mid; // 范围缩小到 (mid, right)
            } else {
                right = mid; // 范围缩小到 (left, mid)
            }
        }
        return right;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        // 向左最远能到 fruits[left][0]
        int left = ranges::lower_bound(fruits, startPos - k, {}, [](auto &f) { return f[0]; }) - fruits.begin();

        int ans = 0, s = 0, n = fruits.size();
        // 枚举最右走到 fruits[right][0]
        for (int right = left; right < n && fruits[right][0] <= startPos + k; right++) {
            s += fruits[right][1];
            while (fruits[right][0] * 2 - fruits[left][0] - startPos > k &&
                   fruits[right][0] - fruits[left][0] * 2 + startPos > k) {
                s -= fruits[left][1]; // fruits[left][0] 太远了
                left++;
            }
            ans = max(ans, s); // 更新答案最大值
        }
        return ans;
    }
};
```

```go [sol-Go]
func maxTotalFruits(fruits [][]int, startPos, k int) (ans int) {
	n := len(fruits)
	// 向左最远能到 fruits[left][0]
	left := sort.Search(n, func(i int) bool { return fruits[i][0] >= startPos-k })

	s := 0
	// 枚举最右走到 fruits[right][0]
	for right := left; right < n && fruits[right][0] <= startPos+k; right++ {
		s += fruits[right][1]
		for fruits[right][0]*2-fruits[left][0]-startPos > k &&
			fruits[right][0]-fruits[left][0]*2+startPos > k {
			s -= fruits[left][1] // fruits[left][0] 太远了
			left++
		}
		ans = max(ans, s) // 更新答案最大值
	}
	return
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n)$，其中 $n$ 为 $\textit{fruits}$ 的长度。虽然写了个二重循环，但是内层循环中对 $\textit{left}$ 加一的**总**执行次数不会超过 $n$ 次，所以总的时间复杂度为 $\mathcal{O}(n)$。
- 空间复杂度：$\mathcal{O}(1)$。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、二叉树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA/一般树）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
