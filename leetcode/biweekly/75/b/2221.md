## 方法一：模拟

无需 $\textit{newNums}$，直接原地把 $\textit{nums}[i]$ 更新为 $(\textit{nums}[i] + \textit{nums}[i+1])\bmod 10$。

每循环一次，把 $\textit{nums}$ 的长度减一。

![lc2221.png](https://pic.leetcode.cn/1757988106-DlcZTQ-lc2221.png){:width=260}

示例 1 的 $\textit{nums}=[1,2,3,4,5]$。

一轮循环后，$\textit{nums}=[1+2,2+3,3+4,4+5] = [3,5,7,9]$。

再循环一轮，$\textit{nums}=[3+5,5+7,7+9] = [8,2,6]$（模 $10$）。

依此类推，循环直到 $\textit{nums}$ 只剩一个数。

最终答案为 $\textit{nums}[0]$。

```py [sol-Python3]
class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        # 每循环一轮，数组长度就减一
        for n in range(len(nums) - 1, 0, -1):
            for i in range(n):
                nums[i] = (nums[i] + nums[i + 1]) % 10
        return nums[0]
```

```java [sol-Java]
class Solution {
    public int triangularSum(int[] nums) {
        // 每循环一轮，数组长度就减一
        for (int n = nums.length - 1; n > 0; n--) {
            for (int i = 0; i < n; i++) {
                nums[i] = (nums[i] + nums[i + 1]) % 10;
            }
        }
        return nums[0];
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    int triangularSum(vector<int>& nums) {
        // 每循环一轮，数组长度就减一
        for (int n = nums.size() - 1; n > 0; n--) {
            for (int i = 0; i < n; i++) {
                nums[i] = (nums[i] + nums[i + 1]) % 10;
            }
        }
        return nums[0];
    }
};
```

```go [sol-Go]
func triangularSum(nums []int) int {
	// 每循环一轮，数组长度就减一
	for n := len(nums) - 1; n > 0; n-- {
		for i := range n {
			nums[i] = (nums[i] + nums[i+1]) % 10
		}
	}
	return nums[0]
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n^2)$，其中 $n$ 是 $\textit{nums}$ 的长度。
- 空间复杂度：$\mathcal{O}(1)$。

## 方法二：组合数学

### 公式推导

能否把最终答案与原数组的元素联系起来？

例如 $\textit{nums}=[a,b,c]$，操作一轮后变成 $[a+b, b+c]$，再操作一轮后变成 $[a+2b+c]$。

又例如 $\textit{nums}=[a,b,c,d]$，操作一轮后变成 $[a+b,b+c,c+d]$，再操作一轮后变成 $[a+2b+c,b+2c+d]$，再操作一轮后变成 $[a+3b+3c+d]$。

又例如 $\textit{nums}=[a,b,c,d,e]$，倒数第二轮是 $[a+3b+3c+d, b+3c+3d+e]$，相加得到 $[a+4b+6c+4d+e]$。

这和 [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/) 的计算过程是一样的，比如 $1,4,6,4,1$ 可以理解成 $1,3,3,1,0$ 加上 $0,1,3,3,1$。所以（根据数学归纳法）系数就是组合数。

也可以从 [62. 不同路径](https://leetcode.cn/problems/unique-paths/) 的角度理解。比如第一排的 $\textit{nums}[1]=2$，在最终答案中的系数是 $4$，这等于从第一排的 $2$ 移动到底部的**路径数**。

![lc2221.png](https://pic.leetcode.cn/1757988106-DlcZTQ-lc2221.png){:width=260}

根据 [62 我的题解](https://leetcode.cn/problems/unique-paths/solutions/3062432/liang-chong-fang-fa-dong-tai-gui-hua-zu-o5k32/) 的方法二，我们要走 $n-1$ 步，其中恰好有 $i$ 步要往左下走，恰好有 $n-1-i$ 步要往右下走，问题变成从 $n-1$ 步中选择 $i$ 步往左下走的方案数。所以在最终答案中，$\textit{nums}[i]$ 的系数是组合数

$$
\dbinom {n-1} {i}
$$

最终答案为

$$
\left(\sum_{i=0}^{n-1} \dbinom {n-1} {i} \cdot \textit{nums}[i]\right)\bmod 10
$$

### 分离因子 2 和 5，欧拉定理求逆元

关于组合数取模的原理，请看 [模运算的世界：当加减乘除遇上取模](https://leetcode.cn/circle/discuss/mDfnkW/)。

本题由于模数 $10$ 不是质数，计算逆元无法用费马小定理，怎么办？

把每个数中的质因子 $2$ 和 $5$ 分离出来，并统计质因子 $2$ 和 $5$ 的个数。一个数去掉其中所有质因子 $2$ 和 $5$ 之后，得到的整数 $a$ 与 $10$ 互质，这样就可以用**欧拉定理**计算整数 $a$ 在模 $10$ 下的逆元，即 $a^{\varphi(10)-1} = a^3$。

### 细节

在计算组合数时，需要把分离出来的质因子 $2$ 和 $5$ 再乘回去。

预处理 $2$ 的幂模 $10$：由于 $2^i\bmod 10\ (i>0)$ 按照 $2,4,8,6$ 的周期循环，所以只需处理一个长为 $4$ 的数组 $[2,4,8,6]$。

预处理 $5$ 的幂模 $10$：由于 $i>0$ 时，$5^i\bmod 10 = 5$ 恒成立，所以无需预处理。

具体请看 [视频讲解](https://www.bilibili.com/video/BV1hiAUeWEUG/?t=3m44s)，欢迎点赞关注~

```py [sol-Python3]
class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        n = len(nums)
        # 直接调用 math.comb 算出来的组合数很大，更快的写法见【Python3 预处理】
        return sum(comb(n - 1, i) * x for i, x in enumerate(nums)) % 10
```

```py [sol-Python3 预处理]
MOD = 10
MX = 1000
POW2 = (2, 4, 8, 6)

# 计算组合数，需要计算阶乘及其逆元
f = [0] * (MX + 1)  # f[n] = n!
inv_f = [0] * (MX + 1)  # inv_f[n] = n!^-1
p2 = [0] * (MX + 1)  # n! 中的 2 的幂次
p5 = [0] * (MX + 1)  # n! 中的 5 的幂次

f[0] = inv_f[0] = 1
for i in range(1, MX + 1):
    x = i

    # 分离质因子 2，计算 2 的幂次
    e2 = (x & -x).bit_length() - 1
    x >>= e2

    # 分离质因子 5，计算 5 的幂次
    e5 = 0
    while x % 5 == 0:
        e5 += 1
        x //= 5

    f[i] = f[i - 1] * x % MOD
    inv_f[i] = pow(f[i], 3, MOD)  # 欧拉定理求逆元
    p2[i] = p2[i - 1] + e2
    p5[i] = p5[i - 1] + e5

def comb(n: int, k: int) -> int:
    e2 = p2[n] - p2[k] - p2[n - k]
    return f[n] * inv_f[k] * inv_f[n - k] * \
        (POW2[(e2 - 1) % 4] if e2 else 1) * \
        (5 if p5[n] - p5[k] - p5[n - k] else 1)

class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        n = len(nums)
        return sum(comb(n - 1, i) * x for i, x in enumerate(nums)) % MOD
```

```java [sol-Java]
class Solution {
    private static final int MOD = 10;
    private static final int MX = 1000;
    private static final int[] POW2 = new int[]{2, 4, 8, 6};

    // 计算组合数，需要计算阶乘及其逆元
    private static final int[] f = new int[MX + 1]; // f[n] = n!
    private static final int[] invF = new int[MX + 1]; // invF[n] = n!^-1
    private static final int[] p2 = new int[MX + 1]; // n! 中的 2 的幂次
    private static final int[] p5 = new int[MX + 1]; // n! 中的 5 的幂次

    private static boolean initialized = false;

    // 这样写比 static block 快
    private void init() {
        if (initialized) {
            return;
        }
        initialized = true;

        f[0] = invF[0] = 1;
        for (int i = 1; i <= MX; i++) {
            int x = i;

            // 分离质因子 2，计算 2 的幂次
            int e2 = Integer.numberOfTrailingZeros(x);
            x >>= e2;
            
            // 分离质因子 5，计算 5 的幂次
            int e5 = 0;
            while (x % 5 == 0) {
                e5++;
                x /= 5;
            }

            f[i] = f[i - 1] * x % MOD;
            invF[i] = pow(f[i], 3); // 欧拉定理求逆元
            p2[i] = p2[i - 1] + e2;
            p5[i] = p5[i - 1] + e5;
        }
    }

    private int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 > 0) {
                res = res * x % MOD;
            }
            x = x * x % MOD;
            n /= 2;
        }
        return res;
    }

    private int comb(int n, int k) {
        int e2 = p2[n] - p2[k] - p2[n - k];
        return f[n] * invF[k] * invF[n - k] *
                (e2 > 0 ? POW2[(e2 - 1) % 4] : 1) *
                (p5[n] - p5[k] - p5[n - k] > 0 ? 5 : 1) % MOD;
    }

    public int triangularSum(int[] nums) {
        init();
        int n = nums.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += comb(n - 1, i) * nums[i];
        }
        return ans % MOD;
    }
}
```

```cpp [sol-C++]
const int MOD = 10;
const int MX = 1000;
const int POW2[4] = {2, 4, 8, 6};

// 计算组合数，需要计算阶乘及其逆元
int f[MX + 1]; // f[n] = n!
int inv_f[MX + 1]; // invF[n] = n!^-1
int p2[MX + 1]; // n! 中的 2 的幂次
int p5[MX + 1]; // n! 中的 5 的幂次

int qpow(int x, int n) {
    int res = 1;
    while (n > 0) {
        if (n % 2 > 0) {
            res = res * x % MOD;
        }
        x = x * x % MOD;
        n /= 2;
    }
    return res;
}

auto init = []() {
    f[0] = inv_f[0] = 1;
    for (int i = 1; i <= MX; i++) {
        int x = i;

        // 分离质因子 2，计算 2 的幂次
        int e2 = countr_zero((uint32_t) x);
        x >>= e2;

        // 分离质因子 5，计算 5 的幂次
        int e5 = 0;
        while (x % 5 == 0) {
            e5++;
            x /= 5;
        }

        f[i] = f[i - 1] * x % MOD;
        inv_f[i] = qpow(f[i], 3); // 欧拉定理求逆元
        p2[i] = p2[i - 1] + e2;
        p5[i] = p5[i - 1] + e5;
    }
    return 0;
}();

int comb(int n, int k) {
    int e2 = p2[n] - p2[k] - p2[n - k];
    return f[n] * inv_f[k] * inv_f[n - k] *
           (e2 ? POW2[(e2 - 1) % 4] : 1) *
           (p5[n] - p5[k] - p5[n - k] ? 5 : 1) % MOD;
}

class Solution {
public:
    int triangularSum(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += comb(n - 1, i) * nums[i];
        }
        return ans % MOD;
    }
};
```

```go [sol-Go]
const mod = 10

func pow(x, n int) int {
	res := 1
	for ; n > 0; n /= 2 {
		if n%2 > 0 {
			res = res * x % mod
		}
		x = x * x % mod
	}
	return res
}

const mx = 1000

// 计算组合数，需要计算阶乘及其逆元
var (
	f    [mx + 1]int // f[n] = n!
	invF [mx + 1]int // invF[n] = n!^-1
	p2   [mx + 1]int // n! 中的 2 的幂次
	p5   [mx + 1]int // n! 中的 5 的幂次
)

func init() {
	f[0] = 1
	invF[0] = 1
	for i := 1; i <= mx; i++ {
		x := i

		// 分离质因子 2，计算 2 的幂次
		e2 := bits.TrailingZeros(uint(x))
		x >>= e2

		// 分离质因子 5，计算 5 的幂次
		e5 := 0
		for x%5 == 0 {
			e5++
			x /= 5
		}

		f[i] = f[i-1] * x % mod
		invF[i] = pow(f[i], 3) // 欧拉定理求逆元
		p2[i] = p2[i-1] + e2
		p5[i] = p5[i-1] + e5
	}
}

var pow2 = [4]int{2, 4, 8, 6}

func comb(n, k int) int {
	res := f[n] * invF[k] * invF[n-k]
	e2 := p2[n] - p2[k] - p2[n-k]
	if e2 > 0 {
		res *= pow2[(e2-1)%4]
	}
	if p5[n]-p5[k]-p5[n-k] > 0 {
		res *= 5
	}
	return res
}

func triangularSum(nums []int) (ans int) {
	for i, x := range nums {
		ans += comb(len(nums)-1, i) * x
	}
	return ans % mod
}
```

#### 复杂度分析

不计入预处理的时间和空间。

- 时间复杂度：$\mathcal{O}(n)$，其中 $n$ 是 $\textit{nums}$ 的长度。
- 空间复杂度：$\mathcal{O}(1)$。

**注**：本题还可以用 **Lucas 定理**做，见 [我的题解](https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-ii/solutions/3086169/mo-shu-wei-he-shu-shi-de-zu-he-shu-by-en-8x7t/)。

## 相似题目

[3463. 判断操作后字符串中的数字是否相等 II](https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-ii/) 2286

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、二叉树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA/一般树）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
