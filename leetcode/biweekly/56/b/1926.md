首先，请先学会更简单的**二叉树 BFS**，讲解请看[【基础算法精讲 13】](https://www.bilibili.com/video/BV1hG4y1277i/)，本文用双列表实现。

网格图 BFS 与二叉树 BFS 的区别是，二叉树只会往下访问左右儿子，不会往上访问父节点；而网格图存在左右横跳的可能，我们要**避免重复访问**之前访问过的格子。

为此，我们可以在格子坐标 $(i,j)$ 入队前，用一个二维布尔数组 $\textit{vis}$ 标记 $\textit{vis}[i][j] = \texttt{true}$。

这样做的好处是，如果发现要入队的格子坐标的 $\textit{vis}[i][j] = \texttt{true}$，那么就不入队。

这可以避免反复横跳，或者重复访问之前访问过的格子。也能保证队列（列表）中没有重复的格子坐标。

## 写法一

```py [sol-Python3]
class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        m, n = len(maze), len(maze[0])
        vis = [[False] * n for _ in range(m)]

        sx, sy = entrance  # 起点
        vis[sx][sy] = True  # 访问标记
        q = [(sx, sy)]

        ans = 1
        while q:
            tmp = q
            q = []
            for i, j in tmp:
                # 注意起点不算终点，不能在这里判断 (i,j) 是不是终点
                for x, y in (i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j):  # 访问相邻的格子
                    if 0 <= x < m and 0 <= y < n and maze[x][y] == '.' and not vis[x][y]:  # 之前没有访问过
                        if x == 0 or y == 0 or x == m - 1 or y == n - 1:  # 到达终点
                            return ans
                        vis[x][y] = True  # 访问标记
                        q.append((x, y))
            ans += 1
        return -1  # 无法到达终点
```

```java [sol-Java]
class Solution {
    private static final int[][] DIRS = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};

    public int nearestExit(char[][] maze, int[] entrance) {
        int m = maze.length;
        int n = maze[0].length;
        boolean[][] vis = new boolean[m][n];

        int sx = entrance[0];
        int sy = entrance[1]; // 起点
        vis[sx][sy] = true; // 访问标记
        List<int[]> q = List.of(new int[]{sx, sy});

        for (int ans = 1; !q.isEmpty(); ans++) {
            List<int[]> tmp = q;
            q = new ArrayList<>();
            for (int[] p : tmp) {
                // 注意起点不算终点，不能在这里判断 p 是不是终点
                for (int[] d : DIRS) { // 访问相邻的格子
                    int x = p[0] + d[0];
                    int y = p[1] + d[1];
                    if (0 <= x && x < m && 0 <= y && y < n && maze[x][y] == '.' && !vis[x][y]) { // 之前没有访问过
                        if (x == 0 || y == 0 || x == m - 1 || y == n - 1) { // 到达终点
                            return ans;
                        }
                        vis[x][y] = true; // 访问标记
                        q.add(new int[]{x, y});
                    }
                }
            }
        }
        return -1; // 无法到达终点
    }
}
```

```cpp [sol-C++]
class Solution {
    static constexpr int DIRS[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}}; // 左右上下

public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size(), n = maze[0].size();
        vector vis(m, vector<int8_t>(n));

        int sx = entrance[0], sy = entrance[1]; // 起点
        vis[sx][sy] = true; // 访问标记
        vector<pair<int, int>> q = {{sx, sy}};
        for (int ans = 1; !q.empty(); ans++) {
            auto tmp = q;
            q.clear();
            for (auto& [i, j] : tmp) {
                // 注意起点不算终点，不能在这里判断 p 是不是终点
                for (auto [dx, dy] : DIRS) { // 访问相邻的格子
                    int x = i + dx, y = j + dy;
                    if (0 <= x && x < m && 0 <= y && y < n && maze[x][y] == '.' && !vis[x][y]) { // 之前没有访问过
                        if (x == 0 || y == 0 || x == m - 1 || y == n - 1) { // 到达终点
                            return ans;
                        }
                        vis[x][y] = true; // 访问标记
                        q.emplace_back(x, y);
                    }
                }
            }
        }
        return -1; // 无法到达终点
    }
};
```

```go [sol-Go]
type pair struct{ x, y int }
var dirs = []pair{{0, -1}, {0, 1}, {-1, 0}, {1, 0}} // 左右上下

func nearestExit(maze [][]byte, entrance []int) int {
	m, n := len(maze), len(maze[0])
	vis := make([][]bool, m)
	for i := range vis {
		vis[i] = make([]bool, n)
	}

	sx, sy := entrance[0], entrance[1] // 起点
	vis[sx][sy] = true // 访问标记
	q := []pair{{sx, sy}}
	for ans := 1; len(q) > 0; ans++ {
		tmp := q
		q = nil
		for _, p := range tmp {
			// 注意起点不算终点，不能在这里判断 p 是不是终点
			for _, d := range dirs { // 访问相邻的格子
				x, y := p.x+d.x, p.y+d.y
				if 0 <= x && x < m && 0 <= y && y < n && maze[x][y] == '.' && !vis[x][y] { // 之前没有访问过
					if x == 0 || y == 0 || x == m-1 || y == n-1 { // 到达终点
						return ans
					}
					vis[x][y] = true // 访问标记
					q = append(q, pair{x, y})
				}
			}
		}
	}
	return -1 // 无法到达终点
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(mn)$，其中 $m$ 和 $n$ 分别为 $\textit{maze}$ 的行数和列数。
- 空间复杂度：$\mathcal{O}(mn)$。

## 写法二

把 $(i,j)$ 入队时，直接修改 $\textit{maze}[i][j] = 0$，这样可以去掉 $\textit{vis}$。

```py [sol-Python3]
class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        m, n = len(maze), len(maze[0])
        sx, sy = entrance  # 起点
        maze[sx][sy] = None  # 访问标记
        q = [(sx, sy)]

        ans = 1
        while q:
            tmp = q
            q = []
            for i, j in tmp:
                # 注意起点不算终点，不能在这里判断 (i,j) 是不是终点
                for x, y in (i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j):  # 访问相邻的格子
                    if 0 <= x < m and 0 <= y < n and maze[x][y] == '.':  # 之前没有访问过
                        if x == 0 or y == 0 or x == m - 1 or y == n - 1:  # 到达终点
                            return ans
                        maze[x][y] = None  # 访问标记
                        q.append((x, y))
            ans += 1
        return -1  # 无法到达终点
```

```java [sol-Java]
class Solution {
    private static final int[][] DIRS = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};

    public int nearestExit(char[][] maze, int[] entrance) {
        int m = maze.length;
        int n = maze[0].length;
        int sx = entrance[0];
        int sy = entrance[1]; // 起点
        maze[sx][sy] = 0; // 访问标记
        List<int[]> q = List.of(new int[]{sx, sy});

        for (int ans = 1; !q.isEmpty(); ans++) {
            List<int[]> tmp = q;
            q = new ArrayList<>();
            for (int[] p : tmp) {
                // 注意起点不算终点，不能在这里判断 p 是不是终点
                for (int[] d : DIRS) { // 访问相邻的格子
                    int x = p[0] + d[0];
                    int y = p[1] + d[1];
                    if (0 <= x && x < m && 0 <= y && y < n && maze[x][y] == '.') { // 之前没有访问过
                        if (x == 0 || y == 0 || x == m - 1 || y == n - 1) { // 到达终点
                            return ans;
                        }
                        maze[x][y] = 0; // 访问标记
                        q.add(new int[]{x, y});
                    }
                }
            }
        }
        return -1; // 无法到达终点
    }
}
```

```cpp [sol-C++]
class Solution {
    static constexpr int DIRS[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}}; // 左右上下

public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size(), n = maze[0].size();
        int sx = entrance[0], sy = entrance[1]; // 起点
        maze[sx][sy] = 0; // 访问标记
        vector<pair<int, int>> q = {{sx, sy}};
        for (int ans = 1; !q.empty(); ans++) {
            auto tmp = q;
            q.clear();
            for (auto& [i, j] : tmp) {
                // 注意起点不算终点，不能在这里判断 p 是不是终点
                for (auto [dx, dy] : DIRS) { // 访问相邻的格子
                    int x = i + dx, y = j + dy;
                    if (0 <= x && x < m && 0 <= y && y < n && maze[x][y] == '.') { // 之前没有访问过
                        if (x == 0 || y == 0 || x == m - 1 || y == n - 1) { // 到达终点
                            return ans;
                        }
                        maze[x][y] = 0; // 访问标记
                        q.emplace_back(x, y);
                    }
                }
            }
        }
        return -1; // 无法到达终点
    }
};
```

```go [sol-Go]
type pair struct{ x, y int }
var dirs = []pair{{0, -1}, {0, 1}, {-1, 0}, {1, 0}} // 左右上下

func nearestExit(maze [][]byte, entrance []int) int {
	m, n := len(maze), len(maze[0])
	sx, sy := entrance[0], entrance[1] // 起点
	maze[sx][sy] = 0 // 访问标记
	q := []pair{{sx, sy}}
	for ans := 1; len(q) > 0; ans++ {
		tmp := q
		q = nil
		for _, p := range tmp {
			// 注意起点不算终点，不能在这里判断 p 是不是终点
			for _, d := range dirs { // 访问相邻的格子
				x, y := p.x+d.x, p.y+d.y
				if 0 <= x && x < m && 0 <= y && y < n && maze[x][y] == '.' { // 之前没有访问过
					if x == 0 || y == 0 || x == m-1 || y == n-1 { // 到达终点
						return ans
					}
					maze[x][y] = 0 // 访问标记
					q = append(q, pair{x, y})
				}
			}
		}
	}
	return -1 // 无法到达终点
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(mn)$，其中 $m$ 和 $n$ 分别为 $\textit{maze}$ 的行数和列数。
- 空间复杂度：$\mathcal{O}(\min(m,n))$。BFS 按曼哈顿距离逐层扩展。在无限平面上，距离起点为 $d$ 的格子个数为 $4d$（菱形周长）。在网格图上，这会受到 $\min(m,n)$ 的限制，导致每次扩展的格子个数是 $\mathcal{O}(\min(m,n))$。所以队列的大小只有 $\mathcal{O}(\min(m,n))$。

## 专题训练

见下面网格图题单的「**二、网格图 BFS**」。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、二叉树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA/一般树）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
