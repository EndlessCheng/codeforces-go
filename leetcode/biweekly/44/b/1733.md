## 方法一：暴力枚举

题目说，好友关系没有传递性，所以我们只需关心 $\textit{friendships}$ 中的每对好友是否可以沟通，也就是**两人是否都会同一门语言**。

题目说，我们只能选择一门语言并教会一些用户。那么**枚举**选择的语言是 $k = 1,2,3,\dots,n$。

对于不会语言 $k$ 的用户，是否就一定要教他语言 $k$ 呢？

不一定，比如某个用户和他的好友都会说中文，那就不需要教他们外语。

如果我们发现一对好友没有共同语言，那么就需要教其中不会语言 $k$ 的人。

具体来说：

1. 枚举选择的语言是 $k = 1,2,3,\dots,n$。
2. 遍历 $\textit{friendships}$。
3. 如果发现一对好友没有共同语言，那么标记其中不会语言 $k$ 的用户。
    - 代码实现时，可以把 $\textit{languages}[i]$ 转换成哈希集合或者布尔数组，从而快速求出两个集合是否有交集。
4. 遍历结束后，被标记的用户个数，即为需要学习语言 $k$ 的用户数，更新答案的最小值。

```py [sol-Python3]
class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        learned = list(map(set, languages))

        todo_list = []
        for u, v in friendships:
            # u 和 v 减一，下标从 0 开始
            if learned[u - 1].isdisjoint(learned[v - 1]):  # 无交集
                todo_list.append((u - 1, v - 1))

        ans = inf
        for k in range(1, n + 1):  # 枚举需要教的语言 k
            st = set()
            for u, v in todo_list:
                if k not in learned[u]:  # u 需要学习语言 k
                    st.add(u)
                if k not in learned[v]:  # v 需要学习语言 k
                    st.add(v)
            ans = min(ans, len(st))  # len(st) 是需要学习语言 k 的人数
        return ans
```

```py [sol-Python3 写法二]
class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        learned = list(map(set, languages))
        todo_list = [(u - 1, v - 1) for u, v in friendships if learned[u - 1].isdisjoint(learned[v - 1])]

        ans = inf
        for k in range(1, n + 1):  # 枚举需要教的语言 k
            st = set()
            for u, v in todo_list:
                if k not in learned[u]:  # u 需要学习语言 k
                    st.add(u)
                if k not in learned[v]:  # v 需要学习语言 k
                    st.add(v)
            ans = min(ans, len(st))  # len(st) 是需要学习语言 k 的人数
        return ans
```

```java [sol-Java]
class Solution {
    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
        int m = languages.length;
        boolean[][] learned = new boolean[m][n + 1];
        for (int i = 0; i < m; i++) {
            for (int x : languages[i]) {
                learned[i][x] = true;
            }
        }

        List<int[]> todoList = new ArrayList<>();
        next:
        for (int[] f : friendships) {
            int u = f[0] - 1, v = f[1] - 1; // 减一，下标从 0 开始
            for (int x : languages[u]) {
                if (learned[v][x]) { // 两人可以相互沟通，无需学习语言
                    continue next;
                }
            }
            todoList.add(f);
        }

        int ans = m;
        for (int k = 1; k <= n; k++) { // 枚举需要教的语言 k
            Set<Integer> set = new HashSet<>();
            for (int[] f : todoList) {
                int u = f[0] - 1, v = f[1] - 1;
                if (!learned[u][k]) { // u 需要学习语言 k
                    set.add(u);
                }
                if (!learned[v][k]) { // v 需要学习语言 k
                    set.add(v);
                }
            }
            ans = Math.min(ans, set.size()); // set.size() 是需要学习语言 k 的人数
        }
        return ans;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    int minimumTeachings(int n, vector<vector<int>>& languages, vector<vector<int>>& friendships) {
        int m = languages.size();
        vector learned(m, vector<int8_t>(n + 1));
        for (int i = 0; i < m; i++) {
            for (int x : languages[i]) {
                learned[i][x] = true;
            }
        }

        vector<pair<int, int>> todo_list;
        for (auto& f : friendships) {
            int u = f[0] - 1, v = f[1] - 1; // 减一，下标从 0 开始
            bool ok = false;
            for (int x : languages[u]) {
                if (learned[v][x]) { // 两人可以相互沟通，无需学习语言
                    ok = true;
                    break;
                }
            }
            if (!ok) {
                todo_list.emplace_back(u, v);
            }
        }

        int ans = m;
        for (int k = 1; k <= n; k++) { // 枚举需要教的语言 k
            unordered_set<int> st;
            for (auto& [u, v] : todo_list) {
                if (!learned[u][k]) { // u 需要学习语言 k
                    st.insert(u);
                }
                if (!learned[v][k]) { // v 需要学习语言 k
                    st.insert(v);
                }
            }
            ans = min(ans, (int) st.size()); // st.size() 是需要学习语言 k 的人数
        }
        return ans;
    }
};
```

```go [sol-Go]
func minimumTeachings(n int, languages [][]int, friendships [][]int) int {
	m := len(languages)
	learned := make([][]bool, m)
	for i, list := range languages {
		learned[i] = make([]bool, n+1)
		for _, x := range list {
			learned[i][x] = true
		}
	}

	todoList := [][2]int{}
next:
	for _, f := range friendships {
		u, v := f[0]-1, f[1]-1 // 减一，下标从 0 开始
		for _, x := range languages[u] {
			if learned[v][x] { // 两人可以相互沟通，无需学习语言
				continue next
			}
		}
		todoList = append(todoList, [2]int{u, v})
	}

	ans := m
	for k := 1; k <= n; k++ { // 枚举需要教的语言 k
		set := map[int]struct{}{}
		for _, f := range todoList {
			u, v := f[0], f[1]
			if !learned[u][k] { // u 需要学习语言 k
				set[u] = struct{}{}
			}
			if !learned[v][k] { // v 需要学习语言 k
				set[v] = struct{}{}
			}
		}
		ans = min(ans, len(set)) // len(set) 是需要学习语言 k 的人数
	}
	return ans
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(nm+nf)$，其中 $n$ 是语言种数，$m$ 是 $\textit{languages}$ 的长度，$f$ 是 $\textit{friendships}$ 的长度。
- 空间复杂度：$\mathcal{O}(nm + f)$。

## 方法二：计数

比如有 $10$ 个人无法沟通，其中说中文的人最多，有 $8$ 个，那么只需教剩下的 $10-8=2$ 个人中文。

所以统计两类信息：

1. 有多少个人无法沟通，记作 $\textit{total}$。
2. 对于无法沟通的人，遍历这个人的语言列表，把语言 $x$ 的出现次数加一，即 $\textit{cnt}[x]$ 加一。

答案为 $\textit{total} - \max(\textit{cnt})$。

```py [sol-Python3]
class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        learned = list(map(set, languages))

        total = 0
        vis = [False] * len(languages)
        cnt = [0] * (n + 1)

        def add(u: int) -> None:
            if vis[u]:
                return
            vis[u] = True  # 避免重复统计
            nonlocal total
            total += 1
            for x in languages[u]:
                cnt[x] += 1

        for u, v in friendships:
            # u 和 v 减一，下标从 0 开始
            if learned[u - 1].isdisjoint(learned[v - 1]):  # 无交集
                add(u - 1)
                add(v - 1)

        return total - max(cnt)
```

```java [sol-Java]
class Solution {
    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
        int m = languages.length;
        boolean[][] learned = new boolean[m][n + 1]; // 记录每个人学的语言
        for (int i = 0; i < m; i++) {
            for (int x : languages[i]) {
                learned[i][x] = true;
            }
        }

        boolean[] vis = new boolean[m];
        int[] cnt = new int[n + 1];

        next:
        for (int[] f : friendships) {
            int u = f[0] - 1, v = f[1] - 1; // 下标从 0 开始
            for (int x : languages[u]) {
                if (learned[v][x]) { // 两人可以相互沟通，无需学习语言
                    continue next;
                }
            }
            add(u, languages, vis, cnt);
            add(v, languages, vis, cnt);
        }

        int maxCnt = 0;
        for (int c : cnt) {
            maxCnt = Math.max(maxCnt, c);
        }

        return total - maxCnt;
    }

    private int total = 0;

    private int add(int u, int[][] languages, boolean[] vis, int[] cnt) {
        if (vis[u]) {
            return total;
        }
        vis[u] = true; // 避免重复统计
        total++;
        for (int x : languages[u]) {
            cnt[x]++;
        }
        return total;
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    int minimumTeachings(int n, vector<vector<int>>& languages, vector<vector<int>>& friendships) {
        int m = languages.size();
        vector learned(m, vector<int8_t>(n + 1));
        for (int i = 0; i < m; i++) {
            for (int x : languages[i]) {
                learned[i][x] = true;
            }
        }

        int total = 0;
        vector<int8_t> vis(m);
        vector<int> cnt(n + 1);

        auto add = [&](int u) -> void {
            if (vis[u]) {
                return;
            }
            vis[u] = true; // 避免重复统计
            total++;
            for (int x : languages[u]) {
                cnt[x]++;
            }
        };

        for (auto& f : friendships) {
            int u = f[0] - 1, v = f[1] - 1; // 下标从 0 开始
            bool ok = false;
            for (int x : languages[u]) {
                if (learned[v][x]) { // 两人可以相互沟通，无需学习语言
                    ok = true;
                    break;
                }
            }
            if (!ok) {
                add(u);
                add(v);
            }
        }

        return total - ranges::max(cnt);
    }
};
```

```go [sol-Go]
func minimumTeachings(n int, languages [][]int, friendships [][]int) int {
	m := len(languages)
	learned := make([][]bool, m)
	for i, list := range languages {
		learned[i] = make([]bool, n+1)
		for _, x := range list {
			learned[i][x] = true
		}
	}

	total := 0
	vis := make([]bool, m)
	cnt := make([]int, n+1)
	add := func(u int) {
		if vis[u] {
			return
		}
		vis[u] = true // 避免重复统计
		total++
		for _, x := range languages[u] {
			cnt[x]++
		}
	}

next:
	for _, f := range friendships {
		u, v := f[0]-1, f[1]-1 // 减一，下标从 0 开始
		for _, x := range languages[u] {
			if learned[v][x] { // 两人可以相互沟通，无需学习语言
				continue next
			}
		}
		add(u)
		add(v)
	}

	return total - slices.Max(cnt)
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(nm + nf)$，其中 $n$ 是语言种数，$m$ 是 $\textit{languages}$ 的长度，$f$ 是 $\textit{friendships}$ 的长度。
- 空间复杂度：$\mathcal{O}(nm)$。

> 注：可以用 bitset 优化，快速判断两个语言列表是否有交集。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、二叉树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA/一般树）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
