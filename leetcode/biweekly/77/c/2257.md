暴力的想法是，依次检查每个空格子是否被保卫，即检查这个空格子上下左右方向上是否有警卫，且中间没有墙。但这样做的时间复杂度是 $\mathcal{O}(mn(m+n))$。

反过来，遍历警卫及其四个方向的视线，视线所及之处的空格子，标记为被保卫。用一个二维数组 $\textit{guarded}$ 记录被保卫的格子。

最后遍历 $\textit{guarded}$，统计没被保卫的格子个数。

**技巧**：如果 $(x,y)$ 处是警卫或者墙，那么标记 $\textit{guarded}[x][y]=-1$。当我们遍历到 $\textit{guarded}[x][y]=-1$ 时，就不再继续遍历。

```py [sol-Python3]
# 左右上下
DIRS = (0, -1), (0, 1), (-1, 0), (1, 0)

class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        guarded = [[0] * n for _ in range(m)]

        # 标记警卫格子、墙格子
        for x, y in guards:
            guarded[x][y] = -1
        for x, y in walls:
            guarded[x][y] = -1

        # 遍历警卫
        for x0, y0 in guards:
            # 遍历视线
            for dx, dy in DIRS:
                # 视线所及之处，被保卫
                x, y = x0 + dx, y0 + dy
                while 0 <= x < m and 0 <= y < n and guarded[x][y] != -1:
                    guarded[x][y] = 1  # 被保卫
                    x += dx
                    y += dy

        # 统计没被保卫的格子数
        ans = 0
        for row in guarded:
            for x in row:
                if x == 0:  # 没被保卫
                    ans += 1
        return ans
```

```java [sol-Java]
class Solution {
    // 左右上下
    private static final int[][] DIRS = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};

    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        int[][] guarded = new int[m][n];

        // 标记警卫格子、墙格子
        for (int[] g : guards) {
            guarded[g[0]][g[1]] = -1;
        }
        for (int[] w : walls) {
            guarded[w[0]][w[1]] = -1;
        }

        // 遍历警卫
        for (int[] g : guards) {
            // 遍历视线
            for (int[] d : DIRS) {
                int dx = d[0], dy = d[1];
                // 视线所及之处，被保卫
                int x = g[0] + dx, y = g[1] + dy;
                while (0 <= x && x < m && 0 <= y && y < n && guarded[x][y] != -1) {
                    guarded[x][y] = 1; // 被保卫
                    x += dx;
                    y += dy;
                }
            }
        }

        // 统计没被保卫的格子数
        int ans = 0;
        for (int[] row : guarded) {
            for (int x : row) {
                if (x == 0) { // 没被保卫
                    ans++;
                }
            }
        }
        return ans;
    }
}
```

```cpp [sol-C++]
class Solution {
    // 左右上下
    static constexpr int DIRS[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};

public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector guarded(m, vector<int8_t>(n));

        // 标记警卫格子、墙格子
        for (auto& g : guards) {
            guarded[g[0]][g[1]] = -1;
        }
        for (auto& w : walls) {
            guarded[w[0]][w[1]] = -1;
        }

        // 遍历警卫
        for (auto& g : guards) {
            // 遍历视线
            for (auto& [dx, dy] : DIRS) {
                // 视线所及之处，被保卫
                int x = g[0] + dx, y = g[1] + dy;
                while (0 <= x && x < m && 0 <= y && y < n && guarded[x][y] != -1) {
                    guarded[x][y] = 1; // 被保卫
                    x += dx;
                    y += dy;
                }
            }
        }

        // 统计没被保卫的格子数
        int ans = 0;
        for (auto& row : guarded) {
            for (int x : row) {
                if (x == 0) { // 没被保卫
                    ans++;
                }
            }
        }
        return ans;
    }
};
```

```c [sol-C]
// 左右上下
static const int DIRS[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};

int countUnguarded(int m, int n, int** guards, int guardsSize, int* guardsColSize, int** walls, int wallsSize, int* wallsColSize) {
    int** guarded = malloc(sizeof(int*) * m);
    for (int i = 0; i < m; i++) {
        guarded[i] = calloc(n, sizeof(int));
    }

    // 标记警卫格子、墙格子
    for (int i = 0; i < guardsSize; i++) {
        guarded[guards[i][0]][guards[i][1]] = -1;
    }
    for (int i = 0; i < wallsSize; i++) {
        guarded[walls[i][0]][walls[i][1]] = -1;
    }

    // 遍历警卫
    for (int i = 0; i < guardsSize; i++) {
        // 遍历视线
        for (int d = 0; d < 4; d++) {
            int dx = DIRS[d][0], dy = DIRS[d][1];
            int x = guards[i][0] + dx, y = guards[i][1] + dy;
            // 视线所及之处，被保卫
            while (0 <= x && x < m && 0 <= y && y < n && guarded[x][y] != -1) {
                guarded[x][y] = 1; // 被保卫
                x += dx;
                y += dy;
            }
        }
    }

    // 统计没被保卫的格子数
    int ans = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (guarded[i][j] == 0) { // 没被保卫
                ans++;
            }
        }
    }

    for (int i = 0; i < m; i++) {
        free(guarded[i]);
    }
    free(guarded);
    return ans;
}
```

```go [sol-Go]
// 左右上下
var dirs = []struct{ x, y int }{{0, -1}, {0, 1}, {-1, 0}, {1, 0}}

func countUnguarded(m int, n int, guards [][]int, walls [][]int) (ans int) {
	guarded := make([][]int8, m)
	for i := range guarded {
		guarded[i] = make([]int8, n)
	}

	// 标记警卫格子、墙格子
	for _, g := range guards {
		guarded[g[0]][g[1]] = -1
	}
	for _, w := range walls {
		guarded[w[0]][w[1]] = -1
	}

	// 遍历警卫
	for _, g := range guards {
		// 遍历视线
		for _, d := range dirs {
			// 视线所及之处，被保卫
			x, y := g[0]+d.x, g[1]+d.y
			for 0 <= x && x < m && 0 <= y && y < n && guarded[x][y] != -1 {
				guarded[x][y] = 1 // 被保卫
				x += d.x
				y += d.y
			}
		}
	}

	// 统计没被保卫的格子数
	for _, row := range guarded {
		for _, x := range row {
			if x == 0 { // 没被保卫
				ans++
			}
		}
	}
	return
}
```

```js [sol-JavaScript]
// 左右上下
const DIRS = [[0, -1], [0, 1], [-1, 0], [1, 0]];

var countUnguarded = function(m, n, guards, walls) {
    const guarded = Array.from({ length: m }, () => Array(n).fill(0));

    // 标记警卫格子、墙格子
    for (const [x, y] of guards) {
        guarded[x][y] = -1;
    }
    for (const [x, y] of walls) {
        guarded[x][y] = -1;
    }

    // 遍历警卫
    for (const [x0, y0] of guards) {
        // 遍历视线
        for (const [dx, dy] of DIRS) {
            // 视线所及之处，被保卫
            let x = x0 + dx, y = y0 + dy;
            while (0 <= x && x < m && 0 <= y && y < n && guarded[x][y] !== -1) {
                guarded[x][y] = 1; // 被保卫
                x += dx;
                y += dy;
            }
        }
    }

    // 统计没被保卫的格子数
    let ans = 0;
    for (const row of guarded) {
        for (const x of row) {
            if (x === 0) { // 没被保卫
                ans++;
            }
        }
    }
    return ans;
};
```

```rust [sol-Rust]
// 左右上下
const DIRS: [(i32, i32); 4] = [(0, -1), (0, 1), (-1, 0), (1, 0)];

impl Solution {
    pub fn count_unguarded(m: i32, n: i32, guards: Vec<Vec<i32>>, walls: Vec<Vec<i32>>) -> i32 {
        let m = m as usize;
        let n = n as usize;
        let mut guarded = vec![vec![0i8; n]; m];

        // 标记警卫格子、墙格子
        for g in &guards {
            guarded[g[0] as usize][g[1] as usize] = -1;
        }
        for w in walls {
            guarded[w[0] as usize][w[1] as usize] = -1;
        }

        // 遍历警卫
        for g in guards {
            // 遍历视线
            for (dx, dy) in DIRS {
                // 视线所及之处，被保卫
                let mut x = (g[0] + dx) as usize;
                let mut y = (g[1] + dy) as usize;
                while x < m && y < n && guarded[x][y] != -1 {
                    guarded[x][y] = 1; // 被保卫
                    x += dx as usize;
                    y += dy as usize;
                }
            }
        }

        // 统计没被保卫的格子数
        guarded.into_iter().flatten().filter(|&x| x == 0).count() as _
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(mn)$。每个格子至多被标记 $4$ 次。
- 空间复杂度：$\mathcal{O}(mn)$。

## 相似题目

- [1222. 可以攻击国王的皇后](https://leetcode.cn/problems/queens-that-can-attack-the-king/)

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. [链表、二叉树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA/一般树）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
