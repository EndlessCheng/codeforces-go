## 初步分析

分别计算 [1,R] 的方案数和 [1,L-1] 的方案数，二者相减就是答案。

设 f(n) 为 [1,n] 的方案数，不考虑互为逆序。
去掉 f(n) 中的回文方案数，剩下的方案可以两两一对，互为逆序。

所以考虑互为逆序的方案数，就是
(f(n) - 回文方案数) / 2 + 回文方案数 = (f(n) + 回文方案数) / 2。

对于回文方案数，长度不能是偶数（中间两个颜色相同），此时 <= n 变成 <= n-1。
当 n 为奇数时，根据左半就能确定右半，所以只有前 ceil(n/2) 个颜色需要计算方案数。
所以 [1,n] 考虑互为逆序时的方案数为 (f(n) + f(ceil(n/2)) / 2。

## 方法一：矩阵快速幂

定义 dp[i][c1][c2] 表示长为 i 的纸带，位置 i-1 的颜色是 c1，位置 i 的颜色是 c2 时的方案数（不考虑互为逆序）。
枚举位置 i-2 的颜色 c，我们可以从 dp[i-1][c][c1] 转移过来。
由此可以得到一个 16*16 的系数矩阵 M，即 [列向量 n] = M @ [列向量 n-1]，其中 @ 表示矩阵乘法。

但请注意，我们求的不是 dp[n][*][*]，而是前缀和 dp[1][*][*] + dp[2][*][*] + ... + dp[n][*][*]。
怎么处理前缀和？

在列向量的末尾添加一个前缀和项 s[i]。
递推式 s[i] = sum(dp[i][*][*]) + s[i-1] = sum(M @ [列向量 i-1]) + s[i-1]。
这个递推式对应到系数矩阵上，就是：
在最下面新增一行：M 矩阵每一列的和，以及一个 1，即 [sum(M[i][0]), sum(M[i][1]), ..., sum(M[i][15]), 1]。
在最右边新增一列：除了最下面的 1 以外，其余全为 0。

## 方法二：Berlekamp-Massey + Kitamasa

更加无脑的做法。
暴力求出 f(n) 的前若干项，然后用 https://zhuanlan.zhihu.com/p/1966417899825665440 Berlekamp-Massey 算法 得到递推式：
f(n) = f(n-1) + 3f(n-2) - 3f(n-3)   （系数从高到低为 1, 3, -3）
初始值 f(1)=4, f(2)=12, f(3)=26。
特判 n=0，返回 0。

然后用矩阵快速幂或者 https://zhuanlan.zhihu.com/p/1964051212304364939 Kitamasa 算法 求出 f(n)。
注意 f(n) 已经是纸带长为 1~n 的总涂色方案数了。

注：也可以直接计算（逆序去重后的）1~n 的总涂色方案数的递推式：
系数从高到低为 1, 3, -3, 3, -3, -9, 9。
初始值（从 n=1 开始）4, 8, 19, 31, 59, 95, 170。

https://codeforces.com/problemset/submission/93/343440584 方法一
https://paste.ubuntu.com/p/6zKWydyN6N/ 方法一备份
https://codeforces.com/contest/93/submission/346538705 方法二
https://paste.ubuntu.com/p/XbSwYgqZnr/ 方法二备份

[DP],[前缀和],[矩阵快速幂],[矩阵快速幂优化 DP],[Berlekamp-Massey],[Kitamasa]