首先，解决本题的静态版本，即给定集合，计算集合中的美丽三元组个数。
这一步，请想清楚，我们需要维护什么？维护的数据保存在哪？
如果可以把三元组的个数打散在 [1,2e5] 中，就可以用线段树维护了。

由于 z-x <= d 与 y 无关，考虑枚举 z，计算有多少个 (x,y)。
x 必须 >= z-d。
如果 [z-d, z-1] 中有 k 个数，那么 (x,y) 就是从 k 个数选 2 个数的方案数，即 C(k,2) = k*(k-1)/2 = k*k/2 - k/2。

考虑把 k*k/2 - k/2 记在 z 这个位置。
但 k*k/2 - k/2 不好维护，可以拆成 k*k 和 k，每个 z 位置维护 k*k 和 k 两个数。
那么答案就是：所有位置的 k*k 之和 / 2 - 所有位置的 k 之和 / 2。

回到原问题。

添加 v，哪些 z 位置保存的 k*k 和 k 会变大？
由于 k 的定义是 [z-d, z-1] 中的元素个数，所以当 z-d <= v <= z-1，即 z 在 [v+1,v+d] 中时，
k 会增加 1，
k*k 会变成 (k+1)*(k+1) = k*k + 2k + 1，增加了 2k+1。
删除 v 类似。

这里有一个「区间中的每个 k 增加 1」的操作，暗示我们用 Lazy 线段树维护。

线段树的每个节点保存：
区间中的 z 的个数 cnt。
区间中的 z 保存的 k 之和 sumC。
区间中的 z 保存的 k*k 之和 sumC2。
懒标记 f，表示区间中的每个 k 增加 f。

当我们把区间中的每个 k 增加 f 时：
cnt 个 z 保存的 k 都增加了 f，所以：
sumC += cnt * f
由于 (k+f)*(k+f) - k*k = k*f*2 + f*f，所以：
sumC2 += sumC*f*2 + cnt*f*f。
注意更新顺序！先更新 sumC2，再更新 sumC。

当我们添加 v 时，把 v 当作 z，我们需要记录 z 这个位置的 k 和 k*k。
查询集合（线段树）中的 [z-d, z-1] 中的元素个数 k，
那么对于 z 这个位置来说，初始化 cnt=1（这个点只有一个 z），sumC=k，sumC2=k*k。
删除时，cnt、sumC、sumC2 置为 0。

答案为线段树根节点的 (sumC2 - sumC) / 2。

https://codeforces.com/contest/1701/submission/342385593
https://paste.ubuntu.com/p/ZQJqTgs7RN/
