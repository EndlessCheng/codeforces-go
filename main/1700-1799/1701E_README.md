首先，「光标移到文本」开头至多做一次。首尾反复横跳纯属浪费。

这样可以用状态机 DP。
把 s 分成左中右三段：
0. 左：「光标移到文本开头」之后的操作。
1. 中：不做任何操作。这一段必须与 t（的某一段）完全一样。
2. 右：「光标移到文本开头」之前的操作。

定义 f[i+1][j+1][k=0/1/2] 表示 s[0]~s[i] 变成 t[0]~t[j] 的最少操作次数。k 的含义如上文所述。

首先，无论 s[i] 和 t[j] 是否相等，都可以删除 s[i]。
为什么相等也可能要删？比如 s=abb, t=ab，删只要一次操作；如果不删，删前面的 b，需要两次操作。
我们有：
f[i+1][j+1][0] = f[i][j+1][0] + 2。删除一个字母需要先右移光标，再删除。
f[i+1][j+1][1] = f[i+1][j+1][0]。由于有删除操作，直接去 k=0 的状态删除。（这里说“去”是从递归的角度思考的）
f[i+1][j+1][2] = min(f[i][j+1][2]+1, f[i+1][j+1][0])。要么直接删，要么去 k=0 的状态删除。

如果 s[i] = t[j]，我们有：
f[i+1][j+1][0] = f[i][j][0] + 1。右移光标。
f[i+1][j+1][1] = f[i][j][1]。不做任何操作。
f[i+1][j+1][2] = min(f[i][j][2]+1, f[i][j][1])。左移光标，或者去 k=1 的状态。（注：对应到实际操作，这相当于光标移到文本开头。）
删和不删两种情况取 min。

初始值：
f[0][0][0] = 1，f[0][0][1] = f[0][0][2] = 0。光标移到文本开头需要一次操作。
f[i][i+1][k] = inf。s 比 t 短，无法把 s 变成 t。
以下三个对应 j=-1 的情况，同删除。
f[i+1][0][0] = f[i][0][0] + 2
f[i+1][0][1] = f[i+1][0][0]
f[i+1][0][2] = f[i][0][2] + 1

答案：f[n][m][2]。一开始光标在 s 末尾。
如果答案 = inf，输出 -1。

代码实现时，可以用两个数组滚动，优化空间。

https://codeforces.com/contest/1701/submission/316756247
https://www.luogu.com.cn/paste/5vcxglj0
