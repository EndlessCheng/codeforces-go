先把 https://leetcode.cn/problems/maximum-bitwise-and-after-increment-operations/description/ 上场周赛第四题 做了。

注意本题和周赛的区别，那道题只需要选 m 个数，我的做法没有修改 a[i]，每次要重新计算当前位以及高位的代价。
本题所有数都要选，我们可以在计算代价后，把 k 减少代价（如果这一位可以是 1）。这样后面只需关心低位的代价，不再重新计算高位的代价。

现在我们要计算，让答案第 i 位是 1，代价是多少。也就是元素要包含 ans|1<<i。
对于（在所有操作之前）已经包含 ans|1<<i 的元素，无需操作，代价是 0。设这样的元素有 cnt[ans|1<<i]] 个。
其余 n-cnt[ans|1<<i]] 个元素呢？可以分为两类：
第一类是（在所有操作之前）包含 ans，但不包含 1<<i 的元素。这些元素要增大，比如从 001 到 100，需要 +3，而不是 +4。
第二类是（在所有操作之前）不包含 ans 的元素。由于我们已经在之前的循环中增加了这些数，这些元素的低 i 位现在都是 0。这些元素要增大，比如从 000 到 100，直接 +4。
我们可以先增加 n-cnt 个 2^i，再减去第一类元素多操作的次数，即第一类元素的低 i 位之和，记作 f[ans][i]。
综上，预处理 cnt 和 f，就可以 O(1) 求出让答案第 i 位是 1 的代价：((n-cnt[ans|1<<i]) << i) - f[ans][i]。

预处理 cnt。
先统计每个元素（a[i]）的出现次数，作为 cnt 的初始值。现在 cnt[s] 表示恰好等于 s 的元素个数。
然后计算 SOS DP（从超集转移过来），算完后，「恰好」变成「至少」，即包含 s 的元素有 cnt[s] 个。

预处理 f。
先遍历 a[i] 二进制中的每个 0，对于第 j 个 0，把 f[a[i]][j] 增加 a[i] 的低 j 位。
然后计算 SOS DP（从超集转移过来），算完后，「恰好」变成「至少」，f[s][i] 表示：对于包含 s 且第 i 位是 0 的元素，这些元素的低 i 位之和。

特殊情况：如果 k 能够把每个元素都增大到 >= max(a)，那么答案就是平均值 (sum(a) + k) / n。

https://codeforces.com/problemset/submission/1903/357908112
https://paste.ubuntu.com/p/VY5tCJQBmg/

[DP],[SOS DP],[状压 DP],[AND],[试填法],[位运算]
